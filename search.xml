<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OpenMMLab 实战营打卡 - 第 4 课</title>
      <link href="/2023/02/10/MMLab%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/02/10/MMLab%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>目标检测基础与 MMDet</strong></p><h2 id="目标检测简介"><a href="#目标检测简介" class="headerlink" title="目标检测简介"></a>目标检测简介</h2><h3 id="实例应用"><a href="#实例应用" class="headerlink" title="实例应用"></a>实例应用</h3><ul><li>人脸识别<br>身份识别、属性分析<br>……</li><li>智慧城市<br>垃圾检测、非法占道检测、违章停车检测、危险物体检测、自助服务、烟雾和火灾检测、标准着装检测、危险行为检测<br>……</li><li>自动驾驶<br>环境感知、路径规划与控制<br>……</li><li>下游视觉任务<br>文字之别、人体姿态估计<br>……<h3 id="滑窗"><a href="#滑窗" class="headerlink" title="滑窗"></a>滑窗</h3>Sliding Window<blockquote><p>未完待续…</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> MMLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MMLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MMclassification初实践（小白向）</title>
      <link href="/2023/02/07/MM-classification/"/>
      <url>/2023/02/07/MM-classification/</url>
      
        <content type="html"><![CDATA[<p>&#8195;&#8195;由于本人之前没有接触过python和机器学习的相关知识，这次图像分类的配置过程可谓一路艰辛……（悲<br>&#8195;&#8195;不过好在最后终于成功训练出了模型并进行了相应的测试，因此就把这次的配置过程记录下来，就当是一次避坑总结了。过程中也借鉴了一些博主的操作，我在文中都会有所提及。</p><p><strong>配置环境概览:</strong></p><blockquote><p>平台: Windows 11<br>Python: 3.9.16<br>GPU: 本地 GPU<br>CUDA: 11.7<br>cuDNN: 8.5<br>Pytorch: 1.13.1<br>OpenCV: 4.6.0<br>MMCV: 1.7.0<br>MMCls: 0.25.0<br><strong>PS: 自建训练集</strong></p></blockquote><h1 id="一、环境安装"><a href="#一、环境安装" class="headerlink" title="一、环境安装"></a>一、环境安装</h1><p>&#8195;&#8195;整体环境框架如下：<br><img src="/img/cls/3.png" alt=""></p><h2 id="1-CUDA-与-cuDNN-安装"><a href="#1-CUDA-与-cuDNN-安装" class="headerlink" title="1. CUDA 与 cuDNN 安装"></a>1. CUDA 与 cuDNN 安装</h2><p>&#8195;&#8195;网上有很多的教程，这里就不再赘述了，不过我以后有时间会补充上滴。这里推荐一个：<a href="https://blog.csdn.net/weixin_43848614/article/details/117221384">【CUDA】cuda安装</a>。<br>&#8195;&#8195;不过有一点要说明，在安装 CUDA 之前要先看一下自己的显卡最高支持的 CUDA 版本和适合于 Pytorch 的 CUDA 版本，版本安装错了后面会出现很多问题。<br>&#8195;&#8195;比如我的 NVIDIA GPU 最高支持到 CUDA 12.0，Pytorch 官网目前最高支持到 CUDA 11.7，因此选择 CUDA 11.7 就 OK。</p><h2 id="2-ANACONDA-环境与-Pycharm-配置"><a href="#2-ANACONDA-环境与-Pycharm-配置" class="headerlink" title="2. ANACONDA 环境与 Pycharm 配置"></a>2. ANACONDA 环境与 Pycharm 配置</h2><h3 id="2-1-ANACONDA-安装"><a href="#2-1-ANACONDA-安装" class="headerlink" title="2.1 ANACONDA 安装"></a>2.1 ANACONDA 安装</h3><p>&#8195;&#8195;ANACONDA（conda）不仅自带了许多 Python 的包，同时可以创建 Python 虚拟环境，与系统自身的环境相隔离，方便一大堆包的管理。这里参考 <a href="https://blog.csdn.net/in546/article/details/117400839">anaconda安装超详细版</a>。</p><ul><li>下载：<br><a href="https://www.anaconda.com">官网</a><br><a href="https://mirrors.bfsu.edu.cn/anaconda/archive">镜像站</a>（速度快，推荐，如下图）<br><img src="/img/cls/1.png" alt=""><br>&#8195;&#8195;版本选择合适的即可，我选择的是最新的一个版本 Anaconda3-2022.10-Windows-x86_64.exe ，自带 Python3.9。</li><li>安装：<br>&#8195;&#8195;点击.exe<strong> —— </strong>Next<strong> —— </strong>Next<strong> —— </strong>选择一个合适的安装路径<strong> — </strong>Next<strong> —— </strong>全选（添加 conda 到环境变量中），Install<strong> —— </strong>Next<strong> —— </strong>两个√去掉<strong> —— </strong>Finish<br>&#8195;&#8195;里面有个“添加 conda 到环境变量中”的选项一定要选上！</li><li>检验安装：<br>&#8195;&#8195;在 windows 终端（cmd）输入 <em>python</em> ，回车，查看是否有 Python 环境，若显示 <em>Python 3.9.16</em> 就说明OK。<br>&#8195;&#8195;在 windows 终端（cmd）输入 <em>conda —version</em> ，回车，查看 conda 是否成功安装，若显示 <em>conda 22.9.0</em> 就说明OK。</li><li>更换 conda 源（加快第三方库的安装速度，不然后面急死人）<br>&#8195;&#8195;打开 Anaconda prompt，逐条输入：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>&#8195;&#8195;查看是否已更改下载源：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda config --show channels</span><br></pre></td></tr></table></figure></li><li>创建虚拟环境：<br>&#8195;&#8195;创建一个 Python 虚拟环境，这样方便后面对一大堆 py 包的管理。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看已有虚拟环境：</span><br><span class="line">conda env list</span><br><span class="line">conda info -e</span><br><span class="line"># 创建虚拟环境</span><br><span class="line">conda create -n env_name python=x.x</span><br><span class="line"># 激活虚拟环境</span><br><span class="line">activate env_name</span><br><span class="line"># 删除虚拟环境</span><br><span class="line">conda remove -n env_name --all</span><br><span class="line"># 切换回默认环境</span><br><span class="line">deactivate env_name</span><br><span class="line">activate base</span><br><span class="line">activate</span><br></pre></td></tr></table></figure>&#8195;&#8195;比如我创建虚拟环境为：<em>conda create -n pytorch_env python=3.9</em> 。过程中会让你输入 <em>y（yes）</em>进行确认。<br>&#8195;&#8195;在第一次创建虚拟环境的过程中可能会遇到 SSLErorr 的报错，意思是说需要安装 Open SSL ，网上的教程是到<a href="https://slproweb.com/products/Win32OpenSSL.html">Open SSL 官网</a>下载相应版本的软件，安装过程中勾选 “The Windows system directory”。但是我的电脑因为系统保护等原因还是不行，这时候我发现 conda 的安装目录 <em>ANACODA\Library\bin\</em> 中有 openssl.exe 和 openssl.pdb 这两个文件，我把它们复制到 <em>C:\Windows\System32\</em> 中，意外的就好了（害。</li></ul><h3 id="2-2-在-PyCharm-2022-中使用-conda-虚拟环境"><a href="#2-2-在-PyCharm-2022-中使用-conda-虚拟环境" class="headerlink" title="2.2 在 PyCharm 2022 中使用 conda 虚拟环境"></a>2.2 在 PyCharm 2022 中使用 conda 虚拟环境</h3><p>&#8195;&#8195;可选操作，实际中大部分过程 PyCharm 只被我当作了 python 文件的编辑器，运行全在终端上完成。这个虚拟环境因为我老早之前就用上了，第一次怎么添加的我记不清了，不过我这里推荐一个博客：<a href="https://blog.csdn.net/qq_39417912/article/details/105470790">在pycharm中使用conda虚拟环境（conda虚拟环境是已经创建好的）</a>。</p><h2 id="3-第三方库安装"><a href="#3-第三方库安装" class="headerlink" title="3. 第三方库安装"></a>3. 第三方库安装</h2><p>&#8195;&#8195;<strong>第三方库的安装必须要切换到对应的虚拟环境中去安装！后面对这些库的使用也要在该虚拟环境下进行！</strong><br>&#8195;&#8195;比如我刚才创建好了一个虚拟环境 pytorch_env ，使用 conda 激活该虚拟环境之后，在该虚拟环境下面安装我们所用到的库，之后我想用这些库就切换到该环境即可。</p><h3 id="3-1-Pytorch-安装"><a href="#3-1-Pytorch-安装" class="headerlink" title="3.1 Pytorch 安装"></a>3.1 Pytorch 安装</h3><ul><li>安装：<br>&#8195;&#8195;进入<a href="https://pytorch.org">官网</a>，选择合适的版本：<br><img src="/img/cls/2.png" alt=""><br>&#8195;&#8195;复制最后的那行代码到终端，回车等待安装完毕即可。</li><li>检验安装：<br>&#8195;&#8195;还是该虚拟环境，逐条输入以下语句：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line">import torch</span><br><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure>&#8195;&#8195;若返回 true，就说明目前你所有操作都是正确的。</li></ul><h3 id="3-2-OpenMMLab-相关库安装"><a href="#3-2-OpenMMLab-相关库安装" class="headerlink" title="3.2 OpenMMLab 相关库安装"></a>3.2 OpenMMLab 相关库安装</h3><ul><li>安装 mim<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -U openmim</span><br><span class="line">pip install openmim</span><br></pre></td></tr></table></figure></li><li>安装 mmcv-full<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mim install mmcv-full</span><br></pre></td></tr></table></figure></li><li>安装 MMClassification<br>&#8195;&#8195;按照官方的说法：</li></ul><ol><li>从源码安装（推荐）：希望基于 MMClassification 框架开发自己的图像分类任务，需要添加新的功能，比如新的模型或是数据集，或者使用我们提供的各种工具。</li><li>作为 Python 包安装：只是希望调用 MMClassification 的 API 接口，或者在自己的项目中导入 MMClassification 中的模块。<br>&#8195;&#8195;我使用的是第一种源码安装：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/open-mmlab/mmclassification.git</span><br><span class="line">cd mmclassification</span><br><span class="line">pip install -v -e .</span><br><span class="line"># &quot;-v&quot; 表示输出更多安装相关的信息</span><br><span class="line"># &quot;-e&quot; 表示以可编辑形式安装，这样可以在不重新安装的情况下，让本地修改直接生效</span><br></pre></td></tr></table></figure>&#8195;&#8195;这个时候你的终端就进入了 mmclassification 文件目录中，不出意外，你可以在 <em>C:\Users\User_name\</em> 中找到该文件夹。</li></ol><ul><li>MMcls 测试<br>&#8195;&#8195;下载下面的预训练模型：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mim download mmcls --config resnet50_8xb32_in1k --dest .</span><br></pre></td></tr></table></figure><img src="/img/cls/4.png" alt=""><br>&#8195;&#8195;运行测试脚本：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python demo/image_demo.py demo/demo.JPEG resnet50_8xb32_in1k.py resnet50_8xb32_in1k_20210831-ea4938fc.pth --device cpu</span><br></pre></td></tr></table></figure>&#8195;&#8195;如果出现下图所示的结果，就表明配置工作已经全部结束，接下来就可以进行模型的训练了：<br><img src="/img/cls/5.png" alt=""><br>&#8195;&#8195;如果出现了问题，先看看上述步骤是否有所遗漏，再看看官方文档的教程。如果上述的步骤有任何错误也欢迎在评论区告诉我。</li></ul><h1 id="二、模型训练"><a href="#二、模型训练" class="headerlink" title="二、模型训练"></a>二、模型训练</h1><h2 id="2-1准备数据集"><a href="#2-1准备数据集" class="headerlink" title="2.1准备数据集"></a>2.1准备数据集</h2><p>&#8195;&#8195;我的数据集是在网上下载的 <a href="https://www.dropbox.com/s/snom6v4zfky0flx/flower_dataset.zip?dl=0">flower 数据集</a>，有 5 个文件夹，每个文件夹名对应一种花，分别为：daisy, dandelion, rose, sunflower, tulip, 每种花含有图片 500+ 张，而我们要将这个数据处理成 mmcls 能够处理的文件组织形式—— ImageNet：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flower_dataset</span><br><span class="line">|--- meta</span><br><span class="line">| |--- classmap.txt ——存放类与名称的对应关系</span><br><span class="line">| |--- train.txt ——训练集文件信息</span><br><span class="line">| |--- val.txt ——验证集文件信息</span><br><span class="line">| |--- test.txt ——测试集文件信息</span><br><span class="line">|--- train</span><br><span class="line">| |--- class1 ——某一种花的图片存放目录</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class2</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class3</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class4</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class5</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">|--- val</span><br><span class="line">| |--- class1</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class2</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class3</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class4</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class5</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">|--- test</span><br><span class="line">| |--- class1</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class2</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class3</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class4</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class5</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br></pre></td></tr></table></figure><br><em>Ps：本次训练我没有用到测试集</em><br>&#8195;&#8195;网上也有些博主的文件组织形式和这个略不同，其实问题不大，后期只需要指定对应的文件路径就行。</p><ul><li>Step 1.<br>&#8195;&#8195;我首先创建好了相应的文件夹，然后按照 train : val = 4 : 1 的比例对每一种花的图片进行数据划分，放入对应的 class 文件夹中。当然，我的图片种类比较少，所以就直接手动移动，网上也有博主分享了他们划分数据集的 Python 程序，可以借鉴使用一波。</li><li>Step 2.<br>&#8195;&#8195;向 classmap.txt 文件写入以下内容：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class1 daisy 0</span><br><span class="line">class2 dandelion 1</span><br><span class="line">class3 rose 2</span><br><span class="line">class4 sunflower 3</span><br><span class="line">class5 tulip 4</span><br></pre></td></tr></table></figure>&#8195;&#8195;向 train.txt 和 val.txt 文件中写入如下内容（test.txt 同理）：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class1/A119.jpg 0</span><br><span class="line">class1/A120.jpg 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><p>&#8195;&#8195;当然，这个工作量太大了，我们不可能手写，这里我借用的是一位博主 <a href="https://blog.csdn.net/hzy459176895/article/details/123405552">何小义的AI进阶路</a> 的程序：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">生成train.txt  val.txt  test.txt</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 需要改为您自己的路径</span></span><br><span class="line">root_dir = <span class="string">&quot;/xxx/data/cats_dogs&quot;</span></span><br><span class="line"><span class="comment"># 在该路径下有train val test meta三个文件夹</span></span><br><span class="line">train_dir = os.path.join(root_dir, <span class="string">&quot;train&quot;</span>)</span><br><span class="line">val_dir = os.path.join(root_dir, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">test_dir = os.path.join(root_dir, <span class="string">&quot;test&quot;</span>)</span><br><span class="line">meta_dir = os.path.join(root_dir, <span class="string">&quot;meta&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_txt</span>(<span class="params">images_dir,map_dict</span>):</span><br><span class="line">    <span class="comment"># 读取所有文件名</span></span><br><span class="line">    imgs_dirs = glob.glob(images_dir+<span class="string">&quot;/*/*&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    imgs_dirs = [ii.replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) <span class="keyword">for</span> ii <span class="keyword">in</span> imgs_dirs]</span><br><span class="line">    images_dir = images_dir.replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    typename = images_dir.split(<span class="string">&quot;/&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line">    target_txt_path = os.path.join(meta_dir, typename+<span class="string">&quot;.txt&quot;</span>)</span><br><span class="line">    f = <span class="built_in">open</span>(target_txt_path, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    <span class="comment"># 遍历所有图片名</span></span><br><span class="line">    <span class="keyword">for</span> img_dir <span class="keyword">in</span> imgs_dirs:</span><br><span class="line">        <span class="comment"># 获取第一级目录名称</span></span><br><span class="line">        filename = img_dir.split(<span class="string">&quot;/&quot;</span>)[-<span class="number">2</span>]</span><br><span class="line">        num = map_dict[filename]</span><br><span class="line">        <span class="comment"># 写入文件</span></span><br><span class="line">        relate_name = re.findall(typename+<span class="string">&quot;/([\w / - .]*)&quot;</span>,img_dir)</span><br><span class="line">        f.write(relate_name[<span class="number">0</span>]+<span class="string">&quot; &quot;</span>+num+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_map_dict</span>():</span><br><span class="line">    <span class="comment"># 读取所有类别映射关系</span></span><br><span class="line">    class_map_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(meta_dir, <span class="string">&quot;classmap.txt&quot;</span>),<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> F:</span><br><span class="line">        lines = F.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            line = line.split(<span class="string">&quot;\n&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">            filename, cls, num = line.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">            class_map_dict[filename] = num</span><br><span class="line">    <span class="keyword">return</span> class_map_dict</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"> </span><br><span class="line">    class_map_dict = get_map_dict()</span><br><span class="line">    generate_txt(images_dir=train_dir, map_dict=class_map_dict)</span><br><span class="line">    generate_txt(images_dir=val_dir, map_dict=class_map_dict)</span><br><span class="line">    generate_txt(images_dir=test_dir, map_dict=class_map_dict)</span><br></pre></td></tr></table></figure><br>&#8195;&#8195;然后数据集可以放在任何你想放置的地方，不过我为了调用方便，将数据集专门放在了 <em>mmclassification\data\</em> 文件夹中（要自己新建一个）。</p><h2 id="2-1准备配置文件"><a href="#2-1准备配置文件" class="headerlink" title="2.1准备配置文件"></a>2.1准备配置文件</h2><h3 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h3><p>&#8195;&#8195;在 <em>configs\_base_\</em> 文件夹下有 4 个基本组件类型，分别是：</p><ol><li>模型( model )</li><li>数据( data )</li><li>训练策略( schedule )</li><li>运行设置( runtime )</li></ol><p>&#8195;&#8195;在 <em>configs\</em> 中其他的文件夹则是各训练模型总的配置文件，比如 <em>configs\mobilenet_v2\mobilenet-v2_8xb32_in1k.py</em> 中可以看到该模型的配置属性：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_base_ = [</span><br><span class="line">    <span class="string">&#x27;../_base_/models/mobilenet_v2_1x.py&#x27;</span>,               <span class="comment"># 模型</span></span><br><span class="line">    <span class="string">&#x27;../_base_/datasets/imagenet_bs32_pil_resize.py&#x27;</span>,    <span class="comment"># 数据</span></span><br><span class="line">    <span class="string">&#x27;../_base_/schedules/imagenet_bs256_epochstep.py&#x27;</span>,   <span class="comment"># 训练策略</span></span><br><span class="line">    <span class="string">&#x27;../_base_/default_runtime.py&#x27;</span>                       <span class="comment"># 默认运行设置</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>&#8195;&#8195;你可以选择任何合适的模型，我这里使用的是 resnet18b32x8 模型，因为我对 python 不熟，所以就按照官方的模板进行配置。</p><h3 id="注册自己的数据集"><a href="#注册自己的数据集" class="headerlink" title="注册自己的数据集"></a>注册自己的数据集</h3><p>&#8195;&#8195;新建 <em>mmcls\datasets\flower_dataset.py</em> ，建立自己的数据集定义脚本。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> .builder <span class="keyword">import</span> DATASETS</span><br><span class="line"><span class="keyword">from</span> .base_dataset <span class="keyword">import</span> BaseDataset</span><br><span class="line"></span><br><span class="line"><span class="meta">@DATASETS.register_module()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlowerDatasets</span>(<span class="title class_ inherited__">BaseDataset</span>): <span class="comment"># 这里要记好这个类的名称，之后会用到</span></span><br><span class="line">    CLASSES = [<span class="string">&quot;daisy&quot;</span>, <span class="string">&quot;dandelion&quot;</span>, <span class="string">&quot;rose&quot;</span>, <span class="string">&quot;sunflower&quot;</span>, <span class="string">&quot;tulip&quot;</span>] <span class="comment"># 修改为自己的数据标签</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_annotations</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(self.ann_file, <span class="built_in">str</span>)</span><br><span class="line">        data_infos = []</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.ann_file) <span class="keyword">as</span> f:</span><br><span class="line">            samples = [x.strip().split(<span class="string">&#x27; &#x27;</span>) <span class="keyword">for</span> x <span class="keyword">in</span> f.readlines()]</span><br><span class="line">            <span class="keyword">for</span> filename, gt_label <span class="keyword">in</span> samples:</span><br><span class="line">                info = &#123;<span class="string">&#x27;img_prefix&#x27;</span>: self.data_prefix,</span><br><span class="line">                        <span class="string">&#x27;img_info&#x27;</span>: &#123;<span class="string">&#x27;filename&#x27;</span>: filename&#125;,</span><br><span class="line">                        <span class="string">&#x27;gt_label&#x27;</span>: np.array(gt_label, dtype=np.int64)&#125;</span><br><span class="line">                data_infos.append(info)</span><br><span class="line">            <span class="keyword">return</span> data_infos</span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;在 <em>mmcls\datasets__init__.py</em> 中添加自己定义的数据集，进行注册：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">from</span> .flower_dataset <span class="keyword">import</span> FlowerDatasets <span class="comment"># import 后面是类的名称</span></span><br><span class="line">__all__ = [</span><br><span class="line">    <span class="string">&#x27;BaseDataset&#x27;</span>, <span class="string">&#x27;ImageNet&#x27;</span>, <span class="string">&#x27;CIFAR10&#x27;</span>, <span class="string">&#x27;CIFAR100&#x27;</span>, <span class="string">&#x27;MNIST&#x27;</span>, <span class="string">&#x27;FashionMNIST&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;VOC&#x27;</span>, <span class="string">&#x27;MultiLabelDataset&#x27;</span>, <span class="string">&#x27;build_dataloader&#x27;</span>, <span class="string">&#x27;build_dataset&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;DistributedSampler&#x27;</span>, <span class="string">&#x27;ConcatDataset&#x27;</span>, <span class="string">&#x27;RepeatDataset&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ClassBalancedDataset&#x27;</span>, <span class="string">&#x27;DATASETS&#x27;</span>, <span class="string">&#x27;PIPELINES&#x27;</span>, <span class="string">&#x27;ImageNet21k&#x27;</span>, <span class="string">&#x27;SAMPLERS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;build_sampler&#x27;</span>, <span class="string">&#x27;RepeatAugSampler&#x27;</span>, <span class="string">&#x27;KFoldDataset&#x27;</span>, <span class="string">&#x27;CUB&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;CustomDataset&#x27;</span>, <span class="string">&#x27;StanfordCars&#x27;</span>, <span class="string">&#x27;FlowerDatasets&#x27;</span> <span class="comment"># 将自己类的名称添加到后面</span></span><br><span class="line">]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="设置数据配置文件"><a href="#设置数据配置文件" class="headerlink" title="设置数据配置文件"></a>设置数据配置文件</h3><p>&#8195;&#8195;新建 <em>config_base_\datasets\flower_dataset.py</em>，导入自己的数据，并进行相关操作。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dataset settings</span></span><br><span class="line">dataset_type = <span class="string">&#x27;FlowerDatasets&#x27;</span>  <span class="comment"># 数据集名称，换成自己刚刚注册的那个名字</span></span><br><span class="line">img_norm_cfg = <span class="built_in">dict</span>(  <span class="comment">#图像归一化配置，用来归一化输入的图像</span></span><br><span class="line">    mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>], </span><br><span class="line">std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>], </span><br><span class="line">to_rgb=<span class="literal">True</span>)  <span class="comment"># 是否反转通道，使用 cv2, mmcv 读取图片默认为 BGR 通道顺序，这里 Normalize 均值方差数组的数值是以 RGB 通道顺序， 因此需要反转通道顺序</span></span><br><span class="line"><span class="comment"># 训练数据流水线</span></span><br><span class="line">train_pipeline = [</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;LoadImageFromFile&#x27;</span>),  <span class="comment"># 读取图片</span></span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;RandomResizedCrop&#x27;</span>, size=<span class="number">224</span>),  <span class="comment"># 随机缩放裁剪</span></span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;RandomFlip&#x27;</span>, flip_prob=<span class="number">0.5</span>, direction=<span class="string">&#x27;horizontal&#x27;</span>),  <span class="comment"># 随机翻转</span></span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;Normalize&#x27;</span>, **img_norm_cfg),  <span class="comment"># 归一化</span></span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;ImageToTensor&#x27;</span>, keys=[<span class="string">&#x27;img&#x27;</span>]),  <span class="comment"># image 转为 torch.Tensor</span></span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;ToTensor&#x27;</span>, keys=[<span class="string">&#x27;gt_label&#x27;</span>]),  <span class="comment"># gt_label 转为 torch.Tensor</span></span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;Collect&#x27;</span>, keys=[<span class="string">&#x27;img&#x27;</span>, <span class="string">&#x27;gt_label&#x27;</span>])  <span class="comment"># 图像和标签的集合</span></span><br><span class="line">]</span><br><span class="line"><span class="comment"># 测试数据流水线</span></span><br><span class="line">test_pipeline = [</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;LoadImageFromFile&#x27;</span>),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;Resize&#x27;</span>, size=(<span class="number">256</span>, -<span class="number">1</span>)),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;CenterCrop&#x27;</span>, crop_size=<span class="number">224</span>),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;Normalize&#x27;</span>, **img_norm_cfg),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;ImageToTensor&#x27;</span>, keys=[<span class="string">&#x27;img&#x27;</span>]),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;Collect&#x27;</span>, keys=[<span class="string">&#x27;img&#x27;</span>])  <span class="comment"># test 时不传递 gt_label</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">data_root = <span class="string">&#x27;.../mmclassification/data/flower_dataset&#x27;</span>  <span class="comment"># 你的数据集根目录</span></span><br><span class="line">data = <span class="built_in">dict</span>(</span><br><span class="line">    samples_per_gpu=<span class="number">32</span>,  <span class="comment"># dataloader.batch_size == self.samples_per_gpu  # 每批次样本数量</span></span><br><span class="line">    workers_per_gpu=<span class="number">2</span>,  <span class="comment"># dataloader.num_workers == self.workers_per_gpu  # 1的话表示只有一个进程加载数据</span></span><br><span class="line">    train=<span class="built_in">dict</span>(  <span class="comment"># 训练数据信息</span></span><br><span class="line">        <span class="built_in">type</span>=dataset_type,  <span class="comment"># 数据集名称</span></span><br><span class="line">        data_prefix=data_root + <span class="string">&#x27;/train&#x27;</span>,  <span class="comment"># 对应到指定的文件夹和文件中</span></span><br><span class="line">        ann_file=data_root + <span class="string">&#x27;/meta/train.txt&#x27;</span>,  <span class="comment"># 数据集目录，当不存在 ann_file 时，类别信息从文件夹自动获取</span></span><br><span class="line">        pipeline=train_pipeline),   <span class="comment"># 数据集需要经过的数据流水线</span></span><br><span class="line">    val=<span class="built_in">dict</span>(   <span class="comment"># 验证数据集信息</span></span><br><span class="line">        <span class="built_in">type</span>=dataset_type,</span><br><span class="line">        data_prefix=data_root + <span class="string">&#x27;/val&#x27;</span>,</span><br><span class="line">        ann_file=data_root + <span class="string">&#x27;/meta/val.txt&#x27;</span>,</span><br><span class="line">        pipeline=test_pipeline),</span><br><span class="line">    test=<span class="built_in">dict</span>(   <span class="comment"># 测试数据集信息</span></span><br><span class="line">        <span class="comment"># replace `data/val` with `data/test` for standard test</span></span><br><span class="line">        <span class="built_in">type</span>=dataset_type,</span><br><span class="line">        data_prefix=data_root + <span class="string">&#x27;/val&#x27;</span>,</span><br><span class="line">        ann_file=data_root + <span class="string">&#x27;/meta/val.txt&#x27;</span>,</span><br><span class="line">        pipeline=test_pipeline</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">evaluation = <span class="built_in">dict</span>(  <span class="comment"># evaluation hook 的配置</span></span><br><span class="line">interval=<span class="number">1</span>,  <span class="comment"># 验证期间的间隔，单位为 epoch 或者 iter， 取决于 runner 类型</span></span><br><span class="line">metric=<span class="string">&#x27;accuracy&#x27;</span>)  <span class="comment"># 验证期间使用的指标</span></span><br></pre></td></tr></table></figure></p><h3 id="设置模型配置文件"><a href="#设置模型配置文件" class="headerlink" title="设置模型配置文件"></a>设置模型配置文件</h3><p>&#8195;&#8195;访问 <a href="https://github.com/open-mmlab/mmclassification/blob/dev/docs/en/model_zoo.md">Model Zoo</a>，找到本次训练使用的模型：<br><img src="/img/cls/7.png" alt=""><br>&#8195;&#8195;点击 model，将模型下载到本地。为了方便管理，我统一放在了 <em>mmclassification\checkpoints\</em> 中，（自己新建一个文件夹）。<br>&#8195;&#8195;新建 <em>config_base_\model\flowers_resnet18.py</em>，对模型进行初始化。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># model settings</span></span><br><span class="line">model = <span class="built_in">dict</span>(</span><br><span class="line">    <span class="built_in">type</span>=<span class="string">&#x27;ImageClassifier&#x27;</span>, <span class="comment"># 分类器类型</span></span><br><span class="line">    backbone=<span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&#x27;ResNet&#x27;</span>, <span class="comment"># 主干网络类型</span></span><br><span class="line">        depth=<span class="number">18</span>,  <span class="comment"># 主干网络深度，这里是 18</span></span><br><span class="line">        num_stages=<span class="number">4</span>,  <span class="comment"># 主干网络状态(stages)的数目，这些状态产生的特征图作为后续的 head 的输入</span></span><br><span class="line">        out_indices=(<span class="number">3</span>,),  <span class="comment"># 输出的特征图输出索引。越远离输入图像，索引越大</span></span><br><span class="line">        style=<span class="string">&#x27;pytorch&#x27;</span>,</span><br><span class="line">        init_cfg=<span class="built_in">dict</span>(</span><br><span class="line">            <span class="built_in">type</span>=<span class="string">&#x27;Pretrained&#x27;</span>,</span><br><span class="line">            checkpoint=<span class="string">&#x27;.../mmclassification/checkpoints/resnet18_batch256_imagenet_20200708-34ab8f90.pth&#x27;</span>,  <span class="comment"># 读取预训练模型，这里是它的存放地址，换成自己的</span></span><br><span class="line">            prefix=<span class="string">&#x27;backbone&#x27;</span>,</span><br><span class="line">            ),</span><br><span class="line">        frozen_stages=<span class="number">2</span>,  <span class="comment"># 加入预训练模型时候，冻结前两层（实验证明，冻结部分权重，效果更好）</span></span><br><span class="line">    ),</span><br><span class="line">    neck=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;GlobalAveragePooling&#x27;</span>),  <span class="comment"># 颈网络类型，neck：平均池化</span></span><br><span class="line">    head=<span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&#x27;LinearClsHead&#x27;</span>,  <span class="comment"># 线性分类头</span></span><br><span class="line">        num_classes=<span class="number">5</span>,  <span class="comment"># 输出类别数，与数据集的类别数一致，要自己修改</span></span><br><span class="line">        in_channels=<span class="number">512</span>,  <span class="comment"># 输入通道数，与 neck 的输出通道一致，一般默认</span></span><br><span class="line">        loss=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;CrossEntropyLoss&#x27;</span>, loss_weight=<span class="number">1.0</span>),  <span class="comment"># 损失函数配置信息，分类，交叉熵</span></span><br><span class="line">        topk=(<span class="number">1</span>, <span class="number">5</span>),  <span class="comment"># 评估指标，Top-k 准确率， 这里为 top1 与 top5 准确率</span></span><br><span class="line">        )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="设置训练策略文件"><a href="#设置训练策略文件" class="headerlink" title="设置训练策略文件"></a>设置训练策略文件</h3><p>&#8195;&#8195;可以新建也可以不新建，我直接用的 <em>config_base_\schedules\imagenet_bs256.py</em> 。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用于构建优化器的配置文件。支持 PyTorch 中的所有优化器，同时它们的参数与 PyTorch 里的优化器参数一致</span></span><br><span class="line">optimizer = <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;SGD&#x27;</span>,         <span class="comment"># 优化器类型</span></span><br><span class="line">                lr=<span class="number">0.1</span>,              <span class="comment"># 优化器的学习率，参数的使用细节请参照对应的 PyTorch 文档</span></span><br><span class="line">                momentum=<span class="number">0.9</span>,        <span class="comment"># 动量(Momentum)</span></span><br><span class="line">                weight_decay=<span class="number">0.0001</span>) <span class="comment"># 权重衰减系数(weight decay)。</span></span><br><span class="line"> <span class="comment"># optimizer hook 的配置文件</span></span><br><span class="line">optimizer_config = <span class="built_in">dict</span>(grad_clip=<span class="literal">None</span>)  <span class="comment"># 大多数方法不使用梯度限制(grad_clip)。</span></span><br><span class="line"><span class="comment"># 学习率调整配置，用于注册 LrUpdater hook。</span></span><br><span class="line">lr_config = <span class="built_in">dict</span>(policy=<span class="string">&#x27;step&#x27;</span>,          <span class="comment"># 调度流程(scheduler)的策略，也支持 CosineAnnealing, Cyclic 等</span></span><br><span class="line">                 step=[<span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>])      <span class="comment"># 在 epoch 为 30, 60, 90 时，lr 进行衰减</span></span><br><span class="line">runner = <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;EpochBasedRunner&#x27;</span>,   <span class="comment"># 将使用的 runner 的类别，如 IterBasedRunner 或 EpochBasedRunner</span></span><br><span class="line">            max_epochs=<span class="number">100</span>)              <span class="comment"># runner 总回合数， 对于 IterBasedRunner 使用 `max_iters`</span></span><br></pre></td></tr></table></figure></p><h3 id="运行文件设置"><a href="#运行文件设置" class="headerlink" title="运行文件设置"></a>运行文件设置</h3><p>&#8195;&#8195;在 <em>config_base_\default_runtime.py</em> 中，设置多少批次打印日志，多少次迭代保存一次模型等等。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Checkpoint hook 的配置文件</span></span><br><span class="line">checkpoint_config = <span class="built_in">dict</span>(interval=<span class="number">1</span>)   <span class="comment"># 保存的间隔是 1，单位会根据 runner 不同变动，可以为 epoch 或者 iter。</span></span><br><span class="line"><span class="comment"># 日志配置信息。</span></span><br><span class="line">log_config = <span class="built_in">dict</span>(</span><br><span class="line">    interval=<span class="number">25</span>,                      <span class="comment"># 打印日志的间隔，单位 iters</span></span><br><span class="line">    hooks=[</span><br><span class="line">        <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;TextLoggerHook&#x27;</span>),          <span class="comment"># 用于记录训练过程的文本记录器(logger)。</span></span><br><span class="line">        <span class="comment"># dict(type=&#x27;TensorboardLoggerHook&#x27;)  # 同样支持 Tensorboard 日志</span></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">dist_params = <span class="built_in">dict</span>(backend=<span class="string">&#x27;nccl&#x27;</span>)   <span class="comment"># 用于设置分布式训练的参数，端口也同样可被设置</span></span><br><span class="line">log_level = <span class="string">&#x27;INFO&#x27;</span>             <span class="comment"># 日志的输出级别</span></span><br><span class="line">load_from = <span class="literal">None</span></span><br><span class="line">resume_from = <span class="literal">None</span>             <span class="comment"># 从给定路径里恢复检查点(checkpoints)，训练模式将从检查点保存的轮次开始恢复训练。</span></span><br><span class="line">workflow = [(<span class="string">&#x27;train&#x27;</span>, <span class="number">1</span>)]      <span class="comment"># runner 的工作流程，[(&#x27;train&#x27;, 1)] 表示只有一个工作流且工作流仅执行一次。</span></span><br><span class="line">work_dir = <span class="string">&#x27;work_dir&#x27;</span>          <span class="comment"># 用于保存当前实验的模型检查点和日志的目录文件地址。</span></span><br></pre></td></tr></table></figure></p><h3 id="设置模型主脚本"><a href="#设置模型主脚本" class="headerlink" title="设置模型主脚本"></a>设置模型主脚本</h3><p>&#8195;&#8195;新建 <em>configs\resnet\flower_resnet18_b32x8_imagenet.py</em>，将上述四个配置文件按顺序加入进来。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_base_ = [</span><br><span class="line">    <span class="string">&#x27;../_base_/models/flowers_resnet18.py&#x27;</span>,  <span class="comment"># model config</span></span><br><span class="line">    <span class="string">&#x27;../_base_/datasets/flower_dataset.py&#x27;</span>,  <span class="comment"># data config</span></span><br><span class="line">    <span class="string">&#x27;../_base_/schedules/imagenet_bs256.py&#x27;</span>,  <span class="comment"># schedules config</span></span><br><span class="line">    <span class="string">&#x27;../_base_/default_runtime.py&#x27;</span>  <span class="comment"># runtime config</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="2-2-训练"><a href="#2-2-训练" class="headerlink" title="2.2 训练"></a>2.2 训练</h2><p>&#8195;&#8195;目录 <em>…\mmclassification\tools\</em> 中存放的是 mmcls 相关工具脚本，打开 <em>tools\train.py</em> ，这个就是启动训练的 Python 脚本。修改这两行：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;config&#x27;</span>, default=<span class="string">&quot;configs/resnet/flower_resnet18_b32x8_imagenet.py&quot;</span>, <span class="built_in">help</span>=<span class="string">&#x27;train config file path&#x27;</span>)  <span class="comment"># 添加模型主脚本的相对路径</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--work-dir&#x27;</span>, default=<span class="string">&quot;train_result/flowers&quot;</span>, <span class="built_in">help</span>=<span class="string">&#x27;the dir to save logs and models&#x27;</span>)  <span class="comment"># 添加模型运行结果的保存路径，没有的话会自动创建</span></span><br></pre></td></tr></table></figure><br>&#8195;&#8195;在终端中输入<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python tools/train.py configs/resnet/flower_resnet18_b32x8_imagenet.py</span><br></pre></td></tr></table></figure><br>&#8195;&#8195;就开始了正式训练。结束之后，可以在 <em>train_result\flowers\</em> 中找到训练的结果。其中 latest.pth 就是最终训练好的模型文件。</p><h2 id="2-3-验证"><a href="#2-3-验证" class="headerlink" title="2.3 验证"></a>2.3 验证</h2><p>&#8195;&#8195;测试的脚本在 <em>tools\test.py</em> ，这次我们直接在终端中输入<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python tools/test.py configs/resnet/flower_resnet18_b32x8_imagenet.py train_result/flowers/latest.pth --out=val_res.json --metrics=accuracy</span><br></pre></td></tr></table></figure><br>&#8195;&#8195;测试完成终端便会打印 top1 与 top5 的准确率，同时在 <em>train_result\flowers\val_res.json</em> 中还可以看到更加详细的测试情况。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&#8195;&#8195;配置过程太艰辛了，尤其是像我这种没有任何基础的小白，有任何一个步骤出现了问题后面就都会出错。不过万事开头难，还是要脚踏实地一步一步的来。</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><ul><li><a href="https://mmclassification.readthedocs.io/zh_CN/latest/index.html">MMClassification 官方中文文档</a></li><li><a href="https://github.com/open-mmlab/mmclassification/blob/dev/docs/en/model_zoo.md">MMCls Model Zoo</a></li><li><a href="https://blog.csdn.net/Stone_hello/article/details/117026516">mmclassification图像分类——模型训练</a></li><li><a href="https://blog.csdn.net/hzy459176895/article/details/123405552">记录一次 mmclassification 自定义数据训练和推理</a></li><li><a href="https://blog.csdn.net/weixin_43216130/article/details/115312600">mmclassification自定义数据集并训练</a></li><li><a href="https://blog.csdn.net/weixin_34910922/article/details/107801656">mmclassification-安装使用</a></li><li><a href="https://blog.csdn.net/suiyingy/article/details/125452839">mmclassification安装与调试</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MMLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MMLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来听听歌吧（一）</title>
      <link href="/2023/02/04/%E6%9D%A5%E5%90%AC%E5%90%AC%E6%AD%8C%E5%90%A7%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/02/04/%E6%9D%A5%E5%90%AC%E5%90%AC%E6%AD%8C%E5%90%A7%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="鹿乃-≧▽≦"><a href="#鹿乃-≧▽≦" class="headerlink" title="鹿乃(/≧▽≦)/"></a>鹿乃(/≧▽≦)/</h2>    <div id="aplayer-AzOOKymq" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="8137572853" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#3F51B5"    ></div><p><img src="/img/lunai/鹿乃さん誕生日.png" alt="来源：P 站画师 へちま"><br><em>来源：P 站画师 へちま</em><br><a href="/img/lunai/鹿乃さん誕生日.png">点击下载</a><br><a href="https://www.pixiv.net/artworks/90916471">图片链接</a><br><a href="https://www.pixiv.net/users/1069005">画师主页</a></p>]]></content>
      
      
      <categories>
          
          <category> MUSIC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MUSIC </tag>
            
            <tag> 鹿乃 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenMMLab 实战营打卡 - 第 3 课</title>
      <link href="/2023/02/04/MMLab%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/02/04/MMLab%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>MMcls 实例应用 &amp; 超算平台的使用</strong></p><h2 id="MMClasification"><a href="#MMClasification" class="headerlink" title="MMClasification"></a>MMClasification</h2><p><img src="/img/MMlab/19.png" alt="MMcls"></p><ul><li>深度学习模型的训练涉及几个方面:<br>&#8195;&#8195;1. 模型结构：模型有几层、每层多少通道数等等<br>&#8195;&#8195;2. 数据集：用什么数据训练模型: 数据集划分、数据文件路径、数据增强策略等等<br>&#8195;&#8195;3. 训练策略：梯度下降算法、学习率参数、batch size 训练总轮次、学习率变化策略等等<br>&#8195;&#8195;4. 运行时：GPU 、分布式环境配置等等<br>&#8195;&#8195;5. 一些辅助功能：如打印日志、定时保存 checkpoint 等等</li><li>在 OpenMMLab 项目中，所有这些项目都涵盖在一个配置文件中，一个配置文件定义了一个完整的训练过程：<br>&#8195;&#8195;1. model 字段定义模型<br>&#8195;&#8195;2. data 字段定义数据<br>&#8195;&#8195;3. optimizer、Ir_config 等字段定义训练策略<br>&#8195;&#8195;4. load_from 字段定义与训练模型的参数文件</li><li>配置文件的运作方式如下：<br><img src="/img/MMlab/20.png" alt="配置文件的运作方式"></li><li>图像分类模型的构成：<br><img src="/img/MMlab/21.png" alt="图像分类模型的构成"></li><li>图像分类模型的构建：<br><img src="/img/MMlab/22.png" alt="图像分类模型的构建"></li><li>数据集的构建：<br><img src="/img/MMlab/23.png" alt="数据集的构建"></li><li>定义数据加载流水线：<br><img src="/img/MMlab/24.png" alt="数据加载流水线"></li><li>配置学习策略：<br><img src="/img/MMlab/25.png" alt="学习策略"></li><li>预训练模型库：<br><a href="https://mmclassification.readthedocs.io/en/latest/modelzoo statistics.html">MODEL ZOO SUMMARY</a></li></ul><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li>MMLab 官方主页<br>&#8195;&#8195;<a href="https://space.bilibili.com/1293512903">bilibili-OpenMMLab</a><br>&#8195;&#8195;<a href="https://github.com/open-mmlab">GitHub-OpenMMLab</a></li><li>MMLab 官方中文文档<br>&#8195;&#8195;<font color=blue><a href="https://mmcv.readthedocs.io/zh_CN/latest/">mmcv</a></font><br>&#8195;&#8195;<font color=blue><a href="https://mmengine.readthedocs.io/zh_CN/latest/">mmengine</a></font><br>&#8195;&#8195;<font color=blue><a href="https://mmdetection.readthedocs.io/zh_CN/latest/">mmdetection</a></font><br>&#8195;&#8195;<font color=blue><a href="https://mmclassification.readthedocs.io/zh_CN/latest/">mmclassification</a></font><br>&#8195;&#8195;<font color=blue><a href="https://mmsegmentation.readthedocs.io/zh_CN/latest/">mmsegmentation</a></font></li><li>其他<br>&#8195;&#8195;<font color=blue><a href="/FilesForDownload/北京超级云计算中心使用手册-2022夏季版.pdf">北京超算用户手册_(点击下载)</a></font><br>&#8195;&#8195;<font color=blue><a href="/FilesForDownload/宁夏超算云N30区用户手册v2.4.pdf">宁夏超算N30用户手册_(点击下载)</a></font><br>&#8195;&#8195;<font color=blue><a href="/FilesForDownload/output.lin.pdf">超算平台实例操作代码_(点击下载)</a></font><br>&#8195;&#8195;<font color=blue><a href="https://zhuanlan.zhihu.com/p/580885852">OpenMMLab 2.0 源码阅读和调试「必备」技巧</a></font><br>&#8195;&#8195;<font color=blue><a href="https://zhuanlan.zhihu.com/p/602883781">北京超算云计算平台深度学习环境配置</a></font></li></ul>]]></content>
      
      
      <categories>
          
          <category> MMLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MMLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenMMLab 实战营打卡 - 第 2 课</title>
      <link href="/2023/02/03/MMLab%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/02/03/MMLab%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>图像分类基础与 MMCls</strong></p><h2 id="图像分类概述"><a href="#图像分类概述" class="headerlink" title="图像分类概述"></a>图像分类概述</h2><p>&#8195;&#8195;图像分类问题就是构建一个可实现的计算函数$F:\mathbb{R} ^{H\times W\times 3}\rightarrow \left\{ 1,\cdots ,K \right\} $，且预测结果符合人类认知。但是难点就是图像内容是像素整体呈现出来的结果，和个别像素没有直接的关联，难以设计具体的算法实现。于是需要需要让机器从数据中学习。而机器学习也是有局限的，机器学习算法善于处理低维、分布相对简单的数据，而对于几十万维的复杂数据处理优势就不足了。我们需要更好的图像分类方法。</p><h4 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h4><p>&#8195;&#8195;在 90 年代，人们用计算梯度直方图 (Histogram of Oriented Gradients) 等一些人工算法将图片映射成相对低维的特征向量，这样极大的简化了数据的表达，同时也保留了内容相关的信息，使得机器学习得以处理图像分类问题。<br>&#8195;&#8195;但是这些也只是特征工程 + 机器学习算法实现图像分类，性能和效果还有很大的提升。<br><img src="/img/MMlab/8.png" alt="特征工程"></p><h4 id="特征学习"><a href="#特征学习" class="headerlink" title="特征学习"></a>特征学习</h4><p>&#8195;&#8195;之后人们开始探索从特征工程到特征学习的转变，特征学习其实也就是学习如何产生适合分类的特征，将多个简单特征变换复合构成一个复杂的端到端分类器。这样一来使得图像的分类精度得到进一步的提高。<br><img src="/img/MMlab/9.png" alt="特征学习"></p><h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><p>&#8195;&#8195;在 2012 年的竞赛中，来自多伦多大学的团队首次使用<strong>深度学习方法AlexNet</strong>，一举将错误率降低至 15.3% ，而传统视觉算法的性能已经达到瓶颈。到了 2015 年，卷积网络的性能已经远超传统方法。<br><img src="/img/MMlab/10.png" alt="深度学习"></p><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><h3 id="模型发展概况"><a href="#模型发展概况" class="headerlink" title="模型发展概况"></a>模型发展概况</h3><p>&#8195;&#8195;图像分类 &amp; 视觉基础模型的发展概况如下图所示：<br><img src="/img/MMlab/18.png" alt="深度学习模型发展概况"></p><h3 id="一些基础卷积神经网络模型介绍"><a href="#一些基础卷积神经网络模型介绍" class="headerlink" title="一些基础卷积神经网络模型介绍"></a>一些基础卷积神经网络模型介绍</h3><h4 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h4><p><em>2012</em><br>&#8195;&#8195;该模型是第一个成功实现大规模图像的模型，在 ImageNet 数据集上达到 ~85% 的准确率。一共有 5 个卷积层，3 个全连接层，60M 个可学习的参数。模型使用了 ReLU 激活函数，大幅提高了收敛速度。最重要的是它实现并开源了 cuda-convnet ，使在工程上用 GPU 上训练大规模神经网络成为可能。<br><img src="/img/MMlab/11.png" alt="AlexNet"></p><h4 id="Going-Deeper"><a href="#Going-Deeper" class="headerlink" title="Going Deeper"></a>Going Deeper</h4><p><em>2012~2014</em></p><h4 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h4><p><em>2014</em><br>&#8195;&#8195;该模型将大尺寸的卷积拆解为多层$3\times 3$的卷积，具有 138M 个权重参数。虽然和大卷积核具有相同的感受野，但是具有更少的参数量、更多的层数和表达能力。3x3 卷积可以配合 1 像素的边界填充，维持空间原本的分辨率，具有更好的适用性。<br>&#8195;&#8195;该网络每隔几层倍增通道数、减半分辨率，生成 1/2、1/4 尺度的更高抽象层级的特征。不同层次的特征在尺寸上有简单的比例关系，方便在位置敏感的下游任务中使用，如检测、分割等。<br><img src="/img/MMlab/12.png" alt="VGG"></p><h4 id="GoogleNet"><a href="#GoogleNet" class="headerlink" title="GoogleNet"></a>GoogleNet</h4><p><em>2014</em><br>&#8195;&#8195;该模型使用 Inception 模块堆叠形成，22 个可学习层和仅 7M 的权重参数。最后的分类仅使用单层全连接层，可节省大量参数。<br><img src="/img/MMlab/13.png" alt="GoogleNet"></p><h4 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h4><p><em>V1 2015</em><br>&#8195;&#8195;模型的层数达到一定的程度的时候，正确率会不增反降。因为随着层数的不断加深，深层网络有潜力达到更高的精度，但是常规的优化算法难以找到这个更优的模型。<br>&#8195;&#8195;我们知道卷积退化为恒等映射的时候，深层网络就会回退到浅层网络，因此我们可以让新增加的卷积层拟合一个近似恒等映射，恰好可以进行进一步的优化。<br>&#8195;&#8195;基于上述实验现象，便有了残差建模以及残差网络：<br>&#8195;&#8195;<strong>残差建模</strong>就是让新增加的层拟合浅层网络与深层网络之间的差异，使得模型更容易学习。在这里梯度可以直接回传到浅层网络以监督浅层网络的学习，同时没有引入额外参数，让参数更有的效贡献到最终的模型中。<br><img src="/img/MMlab/14.png" alt="残差学习的基本思路"><br>&#8195;&#8195;<strong>残差网络</strong>以 VGG 为基础，保持多级结构，并增加层数和跨层连接。每级输出分辨率减半，通道倍增，并且全局平均池化压缩空间维度。<br><img src="/img/MMlab/15.png" alt="残差网络特性"><br>&#8195;&#8195;<strong>ResNet</strong> 是多个深浅模型的集成，其中的残差链接让损失曲面更光滑，更容易收敛得到局部或全局最优解。以 ResNet-34 (34 层  ImageNet Top-5) 为例，每级包含若干残差模块，不同残差模块个数不同。如图所示：<br><img src="/img/MMlab/16.png" alt=" ResNet-34"><br>&#8195;&#8195;ResNet 使用两种残差模块，分别为 Basic block 和 Bottleneck block ，Basic block 用于 ResNet-18 和 34，Bottleneck block 用于 ResNet-50 、101 和 152 ，其中 1x1 卷积用于压缩通道，降低计算开销。<br><img src="/img/MMlab/17.png" alt="ResNet中两种残差模块"><br>&#8195;&#8195;ResNet 后续也推出了许多优化版本：</p><ul><li><strong>ResNet B/C/D</strong>：残差模块的局部改进</li><li><strong>ResNeXt</strong>：使用分组卷积，降低参数量</li><li><strong>SEResNet</strong>：在通道维度引入注意力机制</li></ul><h3 id="更强的图像分类模型"><a href="#更强的图像分类模型" class="headerlink" title="更强的图像分类模型"></a>更强的图像分类模型</h3><h4 id="NAS"><a href="#NAS" class="headerlink" title="NAS"></a>NAS</h4><p><em>2016+</em><br>&#8195;&#8195;NAS 全称为神经结构搜索（Neural Architecture Search），代表工作有：NASNet (2017) 、MnasNet (2018) 、EfficientNet (2019) 、RegNet (2020)等。例如 NASNet 使用一个 RNN 预测网络模块和连接方式，使用强化学习方法优化 RNN 使之预测最佳结构。</p><h4 id="Vision-Transformers"><a href="#Vision-Transformers" class="headerlink" title="Vision Transformers"></a>Vision Transformers</h4><p><em>2020+</em><br>&#8195;&#8195;该模型使用 Transformer 替代卷积网络实现图像分类，使用更大的数据集训练，达到超越卷积网络的精度。代表工作有：Vision Transformer (2020) ，Swin-Transformer (2021ICCV 最佳论文)。</p><h4 id="ConvNeXt"><a href="#ConvNeXt" class="headerlink" title="ConvNeXt"></a>ConvNeXt</h4><p><em>2022</em><br>&#8195;&#8195;该模型将 Swin Transformer 的模型元素迁移到卷积网络中，性能反超 Transformer 。</p><h3 id="轻量化卷积神经网络介绍"><a href="#轻量化卷积神经网络介绍" class="headerlink" title="轻量化卷积神经网络介绍"></a>轻量化卷积神经网络介绍</h3><blockquote><p>第二课的知识点比较密集，需要再整理一下，后续会继续进行发布！<em>QAQ</em></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MMLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MMLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenMMLab 实战营打卡 - 第 1 课</title>
      <link href="/2023/02/01/MMLab%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/02/01/MMLab%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>初探深度学习与神经网络</strong></p><h2 id="1-计算机视觉四大基本任务"><a href="#1-计算机视觉四大基本任务" class="headerlink" title="1.计算机视觉四大基本任务"></a>1.计算机视觉四大基本任务</h2><ul><li>1.检测：如特定目标检测，通用目标检测等。</li><li>2.分割：如语义分割、实例分割、关键点检测等。</li><li>3.定位</li><li>4.分类<br>案例：虚拟主播，人脸识别，人体姿态跟踪等等。</li></ul><h2 id="2-MMLab算法框架"><a href="#2-MMLab算法框架" class="headerlink" title="2.MMLab算法框架"></a>2.MMLab算法框架</h2><p>&#8195;&#8195;<strong>MMDetection</strong>：目标检测<br>&#8195;&#8195;<strong>MMClassification</strong>：图像分类<br>&#8195;&#8195;<strong>MMSegmentation</strong>：语义分割<br>&#8195;&#8195;<strong>MMPose &amp;MMHuman3D</strong>：人体姿态<br>&#8195;&#8195;<strong>MMTracking</strong>：目标追踪<br>&#8195;&#8195;<strong>MMAction2</strong>：视频理解分析<br>&#8195;&#8195;<strong>MMOCR</strong>：文字检测<br>&#8195;&#8195;<strong>MMEditing</strong>：图像处理<br>&#8195;&#8195;<strong>……</strong><br><img src="/img/MMlab/1.jpg" alt="算法框架"></p><center>算法框架</center><h2 id="3-机器学习"><a href="#3-机器学习" class="headerlink" title="3.机器学习"></a>3.机器学习</h2><h3 id="为什么要进行机器学习"><a href="#为什么要进行机器学习" class="headerlink" title="为什么要进行机器学习"></a>为什么要进行机器学习</h3><p>&#8195;&#8195;从数据中学习经验，来解决特定问题<br>&#8195;&#8195;一般步骤：<strong>问题</strong>——<strong>收集数据</strong>——<strong>拟合模型</strong></p><h3 id="机器学习的典型范式"><a href="#机器学习的典型范式" class="headerlink" title="机器学习的典型范式"></a>机器学习的典型范式</h3><p>&#8195;&#8195;1.监督学习：数据之间存在某种映射关系，如何基于有限的数据样本推断出这种关系？<br>&#8195;&#8195;2.无监督学习：数据自身是否存在某种“结构或”规律”？<br>&#8195;&#8195;3.强化学习：如何和环境交互，以获得最大收益？</p><h3 id="机器学习的基本流程"><a href="#机器学习的基本流程" class="headerlink" title="机器学习的基本流程"></a>机器学习的基本流程</h3><p>&#8195;&#8195;1.训练：采集一些数据，标注它们的类别，从中选取一部分用于训练分类器，得到一个可以用于分类的分类器；<br>&#8195;&#8195;2.验证：从采集、标注的数据中另外选取一部分，测试所得分类器的分类精度。验证所用的数据不能和训练重合，以保证分类器的<strong>泛化性能</strong>：在一部分数据上训练的分类器可以在其余的数据上表现出足够的分类精度；<br>&#8195;&#8195;3.应用：将经过验证的分类器集成到实际的业务系统中，实现对应的功能。在应用阶段，分类器面对的数据都是在训练、验证阶段没有见过的。</p><h3 id="机器学习中的分类问题"><a href="#机器学习中的分类问题" class="headerlink" title="机器学习中的分类问题"></a>机器学习中的分类问题</h3><h4 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h4><p>&#8195;&#8195;线性分类器假设类别和特征之间存在某种线性关系。针对某个样本$ \left( x_1,x_2 \right) $，计算$ h\left( x_1,x_2 \right) $的值：如果$ h\left( x_1,x_2 \right) <0 $，归类为A类别；如果$ h\left( x_1,x_2 \right) >0 $，归类为B类别。<br>&#8195;&#8195;更一般地，针对$d$维特征向量$ x\in \mathbb{R} ^d $，线性分类器可以在数学上简写成向量内积的形式：</p><p><center>$h_{w, b}(x)=w^{\mathrm{T}} x+b=\left(w_1, w_2, \ldots, w_d, b\right)\left(\begin{array}{c}x_1 \\ x_2 \\ \ldots \\ x_d \\ 1\end{array}\right)$</center><br>&#8195;&#8195;其中$ w=\left( w_1,w_2,…,w_d \right) $为分界面的法向量。一般利用感知器Perceptron来求解分界面，具体步骤如下：<br>&#8195;&#8195;1. 随机初始化分类界面，记其法向量为$ w $；<br>&#8195;&#8195;2. 依次检查每个样本$\left( x_i,y_i \right) $，如果该样本被分类器分错，则把该样本累加到分界面的法向量上，即$ w\gets w+\alpha x_iy_i $，使其向正确的方向旋转一点。<br>&#8195;&#8195;3. 可以证明，如果两类样本线性可分，算法最终会找到可以分开两类样本的分界面。<br>通常，称根据数据求解分类器参数的过程为<strong>训练</strong>或者<strong>学习</strong>。</p><h4 id="非线性分类器"><a href="#非线性分类器" class="headerlink" title="非线性分类器"></a>非线性分类器</h4><p>&#8195;&#8195;例如异或(XOR)是一个基本的布尔函数，是线性不可分的。但是异或函数可以用一个两层的计算图实现：第一层由$x$输入到隐变量$h$，第二层由$h$输出到$y$。</p><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><h4 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h4><p>一些相关的术语解释：<br>&#8195;&#8195;1. 权重weight：不同的权值$w_i$将会得到不同的输出结果。<br>&#8195;&#8195;2. 偏置值bias：输入数据进行加权求和之后，需要加上一个偏置值$b$。<br>&#8195;&#8195;3. 激活函数：给神经网络加入非线性变换$ \sigma \left( z \right) $，使其能够解决非线性分类问题。<br>&#8195;&#8195;4. 多层感知器：单个神经元可以实现线性分类，而通过堆叠多层神经元可实现非线性分类。<br>&#8195;&#8195;5. 多分类任务：如果是多分类任务，那么神经网络的输出就有多个结果 (多选一) $ y_1,y_2,y_3\cdots $，每个输出$y_i$介于0~1之间，且所有输出的和为1，表示为一个有效的概率分布。为了满足多分类任务特性，输出层的激活函数使用$softmax$：</p><p><center> $ \operatorname{softmax}(x)_i=\frac{e^{x_i}}{ \sum_{j=1}^n e^{x_j} } $ </center><br><img src="/img/MMlab/3.png" alt="神经元堆叠"></p><h4 id="神经网络的训练"><a href="#神经网络的训练" class="headerlink" title="神经网络的训练"></a>神经网络的训练</h4><p>&#8195;&#8195;神经网络的训练流程：<strong>计算样本的损失</strong> - <strong>计算样本损失的梯度</strong> - <strong>据梯度信息更新参数</strong><br>一些相关的术语解释：</p><ul><li><p><strong>1.损失函数</strong>：用于衡量神经网络的性能<br>&#8195;&#8195;神经网络的训练目标就是找到一组比较好的可学习参数$w$的值，使得神经网络的性能最好。<br>&#8195;&#8195;从数学意义上讲，就是找到一组参数$w$的值，使得损失函数$L$的值最小。</p></li><li><p><strong>2.梯度下降算法</strong>：寻找最优参数，进而得到最优网络<br>&#8195;&#8195;也就是寻找损失函数曲面的<strong>谷点</strong>。一般有标准梯度下降、随机梯度下降（SGD）、自适应梯度下降。<br><img src="/img/MMlab/5.png" alt="基于梯度下降训练神经网络的整体流程"></p><center>基于梯度下降训练神经网络的整体流程</center></li><li><strong>3.反向传播算法</strong>：计算损失函数$l$对于所有隐层参数$ \mathbf{\Theta } $的梯度<br><img src="/img/MMlab/4.png" alt="反向传播算法"><center>反向传播算法</center></li><li><strong>4.欠拟合、拟合与过拟合</strong><br>欠拟合：<br>&#8195;&#8195;没有捕捉训练数据中的规律，不能准确预测未来(测试集) 数据，模型过于简单。<br>拟合：<br>&#8195;&#8195;捕捉到训练数据中的规律，可以准确预测未来 (测试集) 数据。<br>过拟合：<br>&#8195;&#8195;过度拟合到训练数据中的噪声，不能准确预测未来(测试集)数据，模型过于复杂、且数据不够。<br><img src="/img/MMlab/6.png" alt="欠拟合、拟合与过拟合"><center>欠拟合、拟合与过拟合</center></li><li><strong>5.早停</strong><br>&#8195;&#8195;将训练数据集划分为训练集和验证集，在训练集上训练，周期性在验证集上测试分类精度。当验证集的分类精度达到最值时，停止训练，防止过拟合。<br><img src="/img/MMlab/7.png" alt="早停"><h4 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络(CNN)"></a>卷积神经网络(CNN)</h4>特性：<br>&#8195;&#8195;1.局部连接：像素局部相关<br>&#8195;&#8195;2.共享权重：位移不变性<br><strong>优点</strong>：大量节约参数，有效提取图像特征<br><strong>流程结构</strong>：输入图像 - 卷积层 - 激活层 - 池化层 - 全连接层 - 概率输出 - 类别概率</li></ul><h2 id="4-几个热门AI研究方向"><a href="#4-几个热门AI研究方向" class="headerlink" title="4.几个热门AI研究方向"></a>4.几个热门AI研究方向</h2><ul><li>人工智能的可解释性分析、显著性分析</li><li>图机器学习、图神经网络( AlphaFold2)、知识图谱</li><li>人工智能 + VR/AR/数字人/元宇宙</li><li>轻量化压缩部署 : Web前端、智能手机、服务器、嵌入式硬件</li><li>Al4Science：天文、物理、蛋白质预测、药物设计、数学证明</li><li>做各行各业垂直细分领域的人工智能应用</li><li>神经辐射场 ( NERF )</li><li>扩散生成模型 ( Diffusion )、AIGC、跨模态预训练大模型</li><li>隐私计算、联邦学习、可信计算</li><li>AI基础设施平台( 数据、算力、教学、开源、算法工具包 )</li><li>认知科学 +类脑计算 + 计算神经科学</li></ul>]]></content>
      
      
      <categories>
          
          <category> MMLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MMLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>灰度图像变换——阈值化处理</title>
      <link href="/2023/01/13/%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E9%98%88%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86/"/>
      <url>/2023/01/13/%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E9%98%88%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1、OTSU阈值化"><a href="#1、OTSU阈值化" class="headerlink" title="1、OTSU阈值化"></a>1、OTSU阈值化</h2><p>&#8195;&#8195;最大类间方差算法，步骤如下：<br>&#8195;&#8195;统计每个像素在整幅图中的个数——计算每个像素的概率分布——对灰度值进行遍历搜索，计算当前灰度值下前景背景类间概率——通过目标函数计算出类内与类间方差下对应的阈值。<br>&#8195;&#8195;代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">OTSU</span><span class="params">(Mat srcImg)</span><span class="comment">//输入灰度图像</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> nCols = srcImg.cols;<span class="comment">//纵方向x</span></span><br><span class="line"><span class="type">int</span> nRows = srcImg.rows;<span class="comment">//横方向y</span></span><br><span class="line"><span class="type">int</span> threshold = <span class="number">0</span>;<span class="comment">//输出的灰度阈值</span></span><br><span class="line"><span class="type">int</span> nSumPix[<span class="number">256</span>];<span class="comment">//灰度级统计数组</span></span><br><span class="line"><span class="type">float</span> nProDis[<span class="number">256</span>];<span class="comment">//灰度级概率分布数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)<span class="comment">//初始化统计数组</span></span><br><span class="line">&#123;</span><br><span class="line">nSumPix[i] = <span class="number">0</span>;</span><br><span class="line">nProDis[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nRows; i++)<span class="comment">//统计灰度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nCols; j++)</span><br><span class="line">&#123;</span><br><span class="line">nSumPix[(<span class="type">int</span>)srcImg.<span class="built_in">at</span>&lt;uchar&gt;(i, j)]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)<span class="comment">//计算概率分布</span></span><br><span class="line">&#123;</span><br><span class="line">nProDis[i] = (<span class="type">float</span>)nSumPix[i] / (nCols * nRows);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历灰度级[0, 255]，计算出最大类间方差下的阈值</span></span><br><span class="line"><span class="type">float</span> w0, w1, u0_temp, u1_temp, u0, u1, delta_temp;</span><br><span class="line"><span class="type">double</span> delta_max = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">w0 = w1 = u0_temp = u1_temp = u0 = u1 = delta_temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt;= i)<span class="comment">//背景</span></span><br><span class="line">&#123;</span><br><span class="line">w0 += nProDis[j];</span><br><span class="line">u0_temp += j * nProDis[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//前景</span></span><br><span class="line">&#123;</span><br><span class="line">w1 += nProDis[j];</span><br><span class="line">u1_temp += j * nProDis[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求平均灰度</span></span><br><span class="line">u0 = u0_temp / w0;</span><br><span class="line">u1 = u1_temp / w1;</span><br><span class="line">delta_temp = (<span class="type">float</span>)(w0 * w1 * <span class="built_in">pow</span>((u0 - u1), <span class="number">2</span>));<span class="comment">//求方差</span></span><br><span class="line"><span class="keyword">if</span> (delta_temp &gt; delta_max)<span class="comment">//找出最大方差</span></span><br><span class="line">&#123;</span><br><span class="line">delta_max = delta_temp;</span><br><span class="line">threshold = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> threshold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">Mat srcGray;</span><br><span class="line"><span class="type">int</span> ostuThresHold = <span class="built_in">OTSU</span>(srcGray);<span class="comment">//得到阈值</span></span><br><span class="line">Mat otImg = Mat::<span class="built_in">zeros</span>(srcGray.rows, srcGray.cols, CV_8UC1);<span class="comment">//创建二值图像</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; srcGray.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; srcGray.cols; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (srcGray.<span class="built_in">at</span>&lt;uchar&gt;(i, j) &gt; ostuThresHold)<span class="comment">//灰度像素读取操作</span></span><br><span class="line">otImg.<span class="built_in">at</span>&lt;uchar&gt;(i, j) = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">otImg.<span class="built_in">at</span>&lt;uchar&gt;(i, j) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;otImg_2&quot;</span>, otImg);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2、固定阈值化"><a href="#2、固定阈值化" class="headerlink" title="2、固定阈值化"></a>2、固定阈值化</h2><p>&#8195;&#8195;利用阈值化函数threshold：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">threshold</span> <span class="params">(InputArray src, OutputArray dst, <span class="type">double</span> thresh, <span class="type">double</span> maxval, <span class="type">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure></p><ul><li>src:单通道图像组</li><li>dst:输出图像组（与输入图像同样尺寸和类型）</li><li>thresh:表示二值化的分界阈值[0, 255]</li><li>maxVal:表示二值化的最大值[0, 255]<br>OpenCV提供了THRESH_BINARY和THRESH_BINARY_INV两种默认参数，或者定义为：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxVal = <span class="number">255</span>;</span><br></pre></td></tr></table></figure></li><li>type:表示阈值化处理的类型<br>0、1：非黑[255]即白[0]<br>2、3、4：可利用参数maxVal自设</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">type 代码类型</th><th style="text-align:center">值</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">THRESH_BINARY<br>二进制阈值化</td><td style="text-align:center">0</td><td style="text-align:center">$dst\left( x,y \right) =\begin{cases}    \max  val&amp;        src\left( x,y \right) &gt;thresh\\    0&amp;        \text{其他}\\\end{cases}$</td></tr><tr><td style="text-align:center">THRESH_BINARY_INV<br>反二进制阈值化</td><td style="text-align:center">1</td><td style="text-align:center">$dst\left( x,y \right) =\begin{cases}    \max  val&amp;        src\left( x,y \right) \leqslant thresh\\    0&amp;        \text{其他}\\\end{cases}$</td></tr><tr><td style="text-align:center">THRESH_TRUNC<br>截断阈值化</td><td style="text-align:center">2</td><td style="text-align:center">$dst\left( x,y \right) =\begin{cases}    threshold&amp;        src\left( x,y \right) &gt;thresh\\    src\left( x,y \right)&amp;        \text{其他}\\\end{cases}$</td></tr><tr><td style="text-align:center">THRESH_TOZERO<br>阈值化为0</td><td style="text-align:center">3</td><td style="text-align:center">$dst\left( x,y \right) =\begin{cases}    src\left( x,y \right)&amp;        src\left( x,y \right) &gt;thresh\\    0&amp;        \text{其他}\\\end{cases}$</td></tr><tr><td style="text-align:center">THRESH_TOZERO_INV<br>反阈值化为0</td><td style="text-align:center">4</td><td style="text-align:center">$dst\left( x,y \right) =\begin{cases}    threshold&amp;        src\left( x,y \right) &gt;thresh\\    src\left( x,y \right)&amp;        \text{其他}\\\end{cases}$</td></tr></tbody></table></div><h2 id="3、自适应阈值化"><a href="#3、自适应阈值化" class="headerlink" title="3、自适应阈值化"></a>3、自适应阈值化</h2><p>&#8195;&#8195;利用函数adaptiveThreshold：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">adaptiveThreshold</span> <span class="params">(InputArray src, OutputArray dst, <span class="type">double</span> maxVal, <span class="type">int</span> adaptiveMethod, <span class="type">int</span> thresholdType, <span class="type">int</span> blockSize, <span class="type">double</span> C)</span></span>;</span><br></pre></td></tr></table></figure></p><ul><li>adaptiveMethod:自适应算法<br>0：ADAPTIVE_THRESH_MEAN_C<br>1：ADAPTIVE_THRESH_GAUSSIAN_C</li><li>ThresholdType:阈值类型<br>0：THRESH_BINARY<br>1：THRESH_BINART_INV</li><li>blockSize:表示邻块大小用来计算区域阈值，一般为3、5、7……</li><li>C：常数<br>我也不太清楚怎么设QAQ</li></ul><h2 id="4、双阈值化"><a href="#4、双阈值化" class="headerlink" title="4、双阈值化"></a>4、双阈值化</h2><p>&#8195;&#8195;对于图像中有明显的双分界特征，可以利用双阈值法进行操作。不过需要预先设定好两个阈值量，相当于上界和下界，然后将落在二者中间的像素设定为maxVal，其余的像素设定为0。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">Mat srcImg;</span><br><span class="line"><span class="comment">//初始化参数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxVal = <span class="number">255</span>;</span><br><span class="line"><span class="type">int</span> low_threshold=<span class="number">150</span>;</span><br><span class="line"><span class="type">int</span> high_threshold=<span class="number">210</span>;</span><br><span class="line">Mat temp1, temp2, resImg;</span><br><span class="line"><span class="comment">//小阈值操作</span></span><br><span class="line"><span class="built_in">threshold</span>(srcImg, temp1, low_threshold, maxVal, THRESH_BINARY);</span><br><span class="line"><span class="comment">//大阈值操作</span></span><br><span class="line"><span class="built_in">threshold</span>(srcImg, temp2, high_threshold, maxVal, THRESH_BINARY_INV);</span><br><span class="line"><span class="comment">//矩阵与运算得到二值化结果</span></span><br><span class="line"><span class="built_in">bitwise_and</span>(temp1, temp2, resImg);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计之“分赌注问题”</title>
      <link href="/2023/01/12/%E5%88%86%E8%B5%8C%E6%B3%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2023/01/12/%E5%88%86%E8%B5%8C%E6%B3%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><center>摘要</center></h2><p>&#8195;&#8195;分赌注问题又称为点数问题，是法国学者梅雷于1654年向法国数学家帕斯卡提出的。<br>&#8195;&#8195;该问题简单来说就是两个水平相同的赌徒A和B，约定先胜$t$局的人赢得赌注，在赌局中的某时刻，两赌徒终止赌博，此时A胜$r$局，B胜$s$局，应该如何合理分配赌注。赌注问题不仅成为概率论的起源，同时荷兰数学家惠更斯在此基础上撰写《论赌博中的计算》一书，提出了数学期望的概念，推动了概率论的发展。<br>&#8195;&#8195;本文用理论分析运算得出赌注分配的最佳方案，并采用MATLAB仿真实验验证结果的正确性。</p><h2 id="一、问题假设"><a href="#一、问题假设" class="headerlink" title="一、问题假设"></a>一、问题假设</h2><ul><li>假设先胜18局的人赢得赌注，且在A胜10局且B胜7局的时候终止赌博；</li><li>假设赌徒A和B的胜率相同，即每一局A和B都有0.5的机会赢得胜利；</li><li>由于$r$和$s$的大小不影响问题的讨论，不妨假设$r&gt;s$。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">符号说明</th></tr></thead><tbody><tr><td style="text-align:center">$t$</td><td style="text-align:center">获得赌注需要获胜的次数</td></tr><tr><td style="text-align:center">$r$</td><td style="text-align:center">A已经获胜的次数</td></tr><tr><td style="text-align:center">$s$</td><td style="text-align:center">B已经获胜的次数</td></tr><tr><td style="text-align:center">$P_A$</td><td style="text-align:center">A先获胜$t$局的概率</td></tr><tr><td style="text-align:center">$P_B$</td><td style="text-align:center">B先获胜$s$局的概率</td></tr><tr><td style="text-align:center">$P_a$</td><td style="text-align:center">A获胜一局的概率</td></tr><tr><td style="text-align:center">$P_b$</td><td style="text-align:center">B获胜一局的概率</td></tr><tr><td style="text-align:center">$i$</td><td style="text-align:center">比赛结束时的比赛次数</td></tr><tr><td style="text-align:center">$P_{A\left( i \right)}$</td><td style="text-align:center">进行到第$i$局时A先获胜$t$局的概率</td></tr></tbody></table></div><h2 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h2><p>&#8195;&#8195;当终止赌博时，A胜$r$局，B胜$s$局，那么此时A、B两人中任何一人若要赢得$t$次的胜利，最少需要的局数为$t-r$局，最多需要的局数为$2t-r-s-1$局，即有：</p><center> $t-r\leqslant i\leqslant 2t-r-s-1$ </center>&#8195;&#8195;而通过分析我们可以知道，A要想赢得赌注，他必须要再赢$t-s$局；同样，B要想赢得赌注，他必须要再赢$t-r$局，那么问题便可以转化为A再赢$t-r$局或B再赢$t-s$局先发生的概率，由于结果要么A赢得赌注，要么B赢得赌注，这两个概率是互补的，因此可以得到：<center> $P_A+P_B=1$ </center>&#8195;&#8195;由二项分布可以得出，当进行到了第$i$局时，A先获胜$t$局的概率为：<center> $P_{A\left( i \right)}=C_{i-1}^{t-r-1}P_{a}^{t-r-1}P_{b}^{i-1-\left( t-r-1 \right)}*P_a$ </center>&#8195;&#8195;那么对每一局的概率进行求和便可得出A先获胜$t$局的概率为：<center> $P_A=\sum_{i=t-r}^{2t-r-s-1}{P_{A\left( i \right)} }$</center>&#8195;&#8195;联立上述式子，并结合已知条件，可以得到：<center> $\begin{cases}    t=18\\ r=10\\ s=7\\    P_A+P_B=1\\    P_a=P_b=0.5\\ P_{A\left( i \right)}=C_{i-1}^{t-r-1}P_{a}^{t-r-1}P_{b}^{i-1-\left( t-r-1 \right)}*P_a\\ P_A=\sum_{i=t-r}^{2t-r-s-1}{P_{A\left( i \right)} }\\ \end{cases}$</center><h2 id="三、问题求解"><a href="#三、问题求解" class="headerlink" title="三、问题求解"></a>三、问题求解</h2><ol><li>编写MATLAB程序，对上述方程组进行求解：<br>&#8195;&#8195;通过计算得出理论值为：$P_A=0.7597$。<br>&#8195;&#8195;因此A应该赢得75.97%的赌注，B应该赢得24.03%的赌注。</li><li>利用MATLAB仿真实验对理论结果进行验证：<br>&#8195;&#8195;假设MATLAB中2*rand()产生的随机数大于1则认为单局赌博A获胜，否则B获胜。以A获胜次数/仿真次数为A获胜的频率，得到仿真结果如下表：</li></ol><center><font face="黑体">表 1 仿真结果统计表</font></center><div class="table-container"><table><thead><tr><th style="text-align:center">仿真次数</th><th style="text-align:center">10</th><th style="text-align:center">100</th><th style="text-align:center">1000</th><th style="text-align:center">10000</th></tr></thead><tbody><tr><td style="text-align:center">A获胜的频率</td><td style="text-align:center">0.8000</td><td style="text-align:center">0.7700</td><td style="text-align:center">0.7530</td><td style="text-align:center">0.7596</td></tr></tbody></table></div><p>&#8195;&#8195;可以看出，当仿真次数为10000次时，A获胜的频率为0.7596，与理论计算的结果相符合，印证了本文采取的计算方法的正确性。</p><h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><blockquote><font color=black>[1]张卓奎，陈慧婵.《概率论与数理统计》. 西安电子科技大学出版社. 2014.6</font></blockquote><h2 id="五、附录"><a href="#五、附录" class="headerlink" title="五、附录"></a>五、附录</h2><figure class="highlight m"><figcaption><span>求解代码</span></figcaption><table><tr><td class="code"><pre><span class="line">clc;clear</span><br><span class="line">t <span class="built_in">=</span> <span class="number">18</span>;</span><br><span class="line">r <span class="built_in">=</span> <span class="number">10</span>;</span><br><span class="line">s <span class="built_in">=</span> <span class="number">7</span>;</span><br><span class="line">p_a <span class="built_in">=</span> <span class="number">0.5</span>;</span><br><span class="line">P_A <span class="built_in">=</span> P(t - r,t - s, p_a)</span><br><span class="line"><span class="comment">%定义 n = t - r; m = t - s</span></span><br><span class="line">function sum <span class="built_in">=</span> P(n, m, p)</span><br><span class="line">    sum <span class="built_in">=</span> <span class="number">0</span>;</span><br><span class="line">    for i <span class="built_in">=</span> n : n + m - <span class="number">1</span></span><br><span class="line">        sum <span class="built_in">=</span> sum + nchoosek(n + m - <span class="number">1</span>, i) * p^(i) * (<span class="number">1</span> - p)^(n + m - <span class="number">1</span> - i);</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><figure class="highlight m"><figcaption><span>仿真代码</span></figcaption><table><tr><td class="code"><pre><span class="line">clear;clc</span><br><span class="line">t <span class="built_in">=</span> <span class="number">18</span>;</span><br><span class="line">r <span class="built_in">=</span> <span class="number">10</span>;</span><br><span class="line">s <span class="built_in">=</span> <span class="number">7</span>;</span><br><span class="line">cout <span class="built_in">=</span> <span class="number">10000</span>;</span><br><span class="line">cout_a <span class="built_in">=</span> <span class="number">0</span>;</span><br><span class="line">cout_b <span class="built_in">=</span> <span class="number">0</span>;</span><br><span class="line">for i <span class="built_in">=</span> <span class="number">1</span> : cout</span><br><span class="line">    i_a <span class="built_in">=</span> r;</span><br><span class="line">    i_b <span class="built_in">=</span> s;</span><br><span class="line">    while i_a &lt; t &amp;&amp; i_b &lt; t</span><br><span class="line">        <span class="built_in">if</span>(<span class="number">2</span> * rand() &gt; <span class="number">1</span>)</span><br><span class="line">            i_a <span class="built_in">=</span> i_a + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">else</span></span><br><span class="line">            i_b <span class="built_in">=</span> i_b + <span class="number">1</span>;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">if</span> i_a <span class="built_in">=</span><span class="built_in">=</span> t</span><br><span class="line">        cout_a <span class="built_in">=</span> cout_a + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">else</span></span><br><span class="line">        cout_b <span class="built_in">=</span> cout_b + <span class="number">1</span>;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">P_A <span class="built_in">=</span> cout_a / cout</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/11/hello-world/"/>
      <url>/2023/01/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
