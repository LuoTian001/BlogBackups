<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MMLab公开课（二）</title>
      <link href="/2023/02/03/MMLab%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/02/03/MMLab%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="图像分类概述"><a href="#图像分类概述" class="headerlink" title="图像分类概述"></a>图像分类概述</h2><p>&#8195;&#8195;图像分类问题就是构建一个可实现的计算函数$F:\mathbb{R} ^{H\times W\times 3}\rightarrow \left\{ 1,\cdots ,K \right\} $，且预测结果符合人类认知。但是难点就是图像内容是像素整体呈现出来的结果，和个别像素没有直接的关联，难以设计具体的算法实现。于是需要需要让机器从数据中学习。而机器学习也是有局限的，机器学习算法善于处理低维、分布相对简单的数据，而对于几十万维的复杂数据处理优势就不足了。我们需要更好的图像分类方法。</p><h4 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h4><p>&#8195;&#8195;在90年代，人们用计算梯度直方图(Histogram of Oriented Gradients)等一些人工算法将图片映射成相对低维的特征向量，这样极大的简化了数据的表达，同时也保留了内容相关的信息，使得机器学习得以处理图像分类问题。<br>&#8195;&#8195;但是这些也只是特征工程+机器学习算法实现图像分类，性能和效果还有很大的提升。<br><img src="/img/MMlab/8.png" alt="特征工程"></p><h4 id="特征学习"><a href="#特征学习" class="headerlink" title="特征学习"></a>特征学习</h4><p>&#8195;&#8195;之后人们开始探索从特征工程到特征学习的转变，特征学习其实也就是学习如何产生适合分类的特征，将多个简单特征变换复合构成一个复杂的端到端分类器。这样一来使得图像的分类精度得到进一步的提高。<br><img src="/img/MMlab/9.png" alt="特征学习"></p><h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><p>&#8195;&#8195;在 2012 年的竞赛中，来自多伦多大学的团队首次使用<strong>深度学习方法AlexNet</strong>，一举将错误率降低至 15.3% ，而传统视觉算法的性能已经达到瓶颈。到了2015 年，卷积网络的性能已经远超传统方法。<br><img src="/img/MMlab/10.png" alt="深度学习"></p><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><blockquote><p>第二课的知识点比较密集，需要再整理一下，后续会继续进行发布！<em>QAQ</em></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MMLab公开课（一）</title>
      <link href="/2023/02/01/MMLab%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/02/01/MMLab%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1-计算机视觉四大基本任务"><a href="#1-计算机视觉四大基本任务" class="headerlink" title="1.计算机视觉四大基本任务"></a>1.计算机视觉四大基本任务</h2><ul><li>1.检测：如特定目标检测，通用目标检测等。</li><li>2.分割：如语义分割、实例分割、关键点检测等。</li><li>3.定位</li><li>4.分类<br>案例：虚拟主播，人脸识别，人体姿态跟踪等等。</li></ul><h2 id="2-MMLab算法框架"><a href="#2-MMLab算法框架" class="headerlink" title="2.MMLab算法框架"></a>2.MMLab算法框架</h2><p>&#8195;&#8195;<strong>MMDetection</strong>：目标检测<br>&#8195;&#8195;<strong>MMClassification</strong>：图像分类<br>&#8195;&#8195;<strong>MMSegmentation</strong>：语义分割<br>&#8195;&#8195;<strong>MMPose &amp;MMHuman3D</strong>：人体姿态<br>&#8195;&#8195;<strong>MMTracking</strong>：目标追踪<br>&#8195;&#8195;<strong>MMAction2</strong>：视频理解分析<br>&#8195;&#8195;<strong>MMOCR</strong>：文字检测<br>&#8195;&#8195;<strong>MMEditing</strong>：图像处理<br>&#8195;&#8195;<strong>……</strong><br><img src="/img/MMlab/1.jpg" alt="算法框架"></p><center>算法框架</center><h2 id="3-机器学习"><a href="#3-机器学习" class="headerlink" title="3.机器学习"></a>3.机器学习</h2><h3 id="为什么要进行机器学习"><a href="#为什么要进行机器学习" class="headerlink" title="为什么要进行机器学习"></a>为什么要进行机器学习</h3><p>&#8195;&#8195;从数据中学习经验，来解决特定问题<br>&#8195;&#8195;一般步骤：<strong>问题</strong>——<strong>收集数据</strong>——<strong>拟合模型</strong></p><h3 id="机器学习的典型范式"><a href="#机器学习的典型范式" class="headerlink" title="机器学习的典型范式"></a>机器学习的典型范式</h3><p>&#8195;&#8195;1.监督学习：数据之间存在某种映射关系，如何基于有限的数据样本推断出这种关系？<br>&#8195;&#8195;2.无监督学习：数据自身是否存在某种“结构或”规律”？<br>&#8195;&#8195;3.强化学习：如何和环境交互，以获得最大收益？</p><h3 id="机器学习的基本流程"><a href="#机器学习的基本流程" class="headerlink" title="机器学习的基本流程"></a>机器学习的基本流程</h3><p>&#8195;&#8195;1.训练：采集一些数据，标注它们的类别，从中选取一部分用于训练分类器，得到一个可以用于分类的分类器；<br>&#8195;&#8195;2.验证：从采集、标注的数据中另外选取一部分，测试所得分类器的分类精度。验证所用的数据不能和训练重合，以保证分类器的<strong>泛化性能</strong>：在一部分数据上训练的分类器可以在其余的数据上表现出足够的分类精度；<br>&#8195;&#8195;3.应用：将经过验证的分类器集成到实际的业务系统中，实现对应的功能。在应用阶段，分类器面对的数据都是在训练、验证阶段没有见过的。</p><h3 id="机器学习中的分类问题"><a href="#机器学习中的分类问题" class="headerlink" title="机器学习中的分类问题"></a>机器学习中的分类问题</h3><h4 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h4><p>&#8195;&#8195;线性分类器假设类别和特征之间存在某种线性关系。针对某个样本$ \left( x_1,x_2 \right) $，计算$ h\left( x_1,x_2 \right) $的值：如果$ h\left( x_1,x_2 \right) <0 $，归类为A类别；如果$ h\left( x_1,x_2 \right) >0 $，归类为B类别。<br>&#8195;&#8195;更一般地，针对$d$维特征向量$ x\in \mathbb{R} ^d $，线性分类器可以在数学上简写成向量内积的形式：</p><p><center>$h_{w, b}(x)=w^{\mathrm{T}} x+b=\left(w_1, w_2, \ldots, w_d, b\right)\left(\begin{array}{c}x_1 \\ x_2 \\ \ldots \\ x_d \\ 1\end{array}\right)$</center><br>&#8195;&#8195;其中$ w=\left( w_1,w_2,…,w_d \right) $为分界面的法向量。一般利用感知器Perceptron来求解分界面，具体步骤如下：<br>&#8195;&#8195;1. 随机初始化分类界面，记其法向量为$ w $；<br>&#8195;&#8195;2. 依次检查每个样本$\left( x_i,y_i \right) $，如果该样本被分类器分错，则把该样本累加到分界面的法向量上，即$ w\gets w+\alpha x_iy_i $，使其向正确的方向旋转一点。<br>&#8195;&#8195;3. 可以证明，如果两类样本线性可分，算法最终会找到可以分开两类样本的分界面。<br>通常，称根据数据求解分类器参数的过程为<strong>训练</strong>或者<strong>学习</strong>。</p><h4 id="非线性分类器"><a href="#非线性分类器" class="headerlink" title="非线性分类器"></a>非线性分类器</h4><p>&#8195;&#8195;例如异或(XOR)是一个基本的布尔函数，是线性不可分的。但是异或函数可以用一个两层的计算图实现：第一层由$x$输入到隐变量$h$，第二层由$h$输出到$y$。</p><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><h4 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h4><p>一些相关的术语解释：<br>&#8195;&#8195;1. 权重weight：不同的权值$w_i$将会得到不同的输出结果。<br>&#8195;&#8195;2. 偏置值bias：输入数据进行加权求和之后，需要加上一个偏置值$b$。<br>&#8195;&#8195;3. 激活函数：给神经网络加入非线性变换$ \sigma \left( z \right) $，使其能够解决非线性分类问题。<br>&#8195;&#8195;4. 多层感知器：单个神经元可以实现线性分类，而通过堆叠多层神经元可实现非线性分类。<br>&#8195;&#8195;5. 多分类任务：如果是多分类任务，那么神经网络的输出就有多个结果 (多选一) $ y_1,y_2,y_3\cdots $，每个输出$y_i$介于0~1之间，且所有输出的和为1，表示为一个有效的概率分布。为了满足多分类任务特性，输出层的激活函数使用$softmax$：</p><p><center> $ \operatorname{softmax}(x)_i=\frac{e^{x_i}}{ \sum_{j=1}^n e^{x_j} } $ </center><br><img src="/img/MMlab/3.png" alt="神经元堆叠"></p><h4 id="神经网络的训练"><a href="#神经网络的训练" class="headerlink" title="神经网络的训练"></a>神经网络的训练</h4><p>&#8195;&#8195;神经网络的训练流程：<strong>计算样本的损失</strong> - <strong>计算样本损失的梯度</strong> - <strong>据梯度信息更新参数</strong><br>一些相关的术语解释：</p><ul><li><p><strong>1.损失函数</strong>：用于衡量神经网络的性能<br>&#8195;&#8195;神经网络的训练目标就是找到一组比较好的可学习参数$w$的值，使得神经网络的性能最好。<br>&#8195;&#8195;从数学意义上讲，就是找到一组参数$w$的值，使得损失函数$L$的值最小。</p></li><li><p><strong>2.梯度下降算法</strong>：寻找最优参数，进而得到最优网络<br>&#8195;&#8195;也就是寻找损失函数曲面的<strong>谷点</strong>。一般有标准梯度下降、随机梯度下降（SGD）、自适应梯度下降。<br><img src="/img/MMlab/5.png" alt="基于梯度下降训练神经网络的整体流程"></p><center>基于梯度下降训练神经网络的整体流程</center></li><li><strong>3.反向传播算法</strong>：计算损失函数$l$对于所有隐层参数$ \mathbf{\Theta } $的梯度<br><img src="/img/MMlab/4.png" alt="反向传播算法"><center>反向传播算法</center></li><li><strong>4.欠拟合、拟合与过拟合</strong><br>欠拟合：<br>&#8195;&#8195;没有捕捉训练数据中的规律，不能准确预测未来(测试集) 数据，模型过于简单。<br>拟合：<br>&#8195;&#8195;捕捉到训练数据中的规律，可以准确预测未来 (测试集) 数据。<br>过拟合：<br>&#8195;&#8195;过度拟合到训练数据中的噪声，不能准确预测未来(测试集)数据，模型过于复杂、且数据不够。<br><img src="/img/MMlab/6.png" alt="欠拟合、拟合与过拟合"><center>欠拟合、拟合与过拟合</center></li><li><strong>5.早停</strong><br>&#8195;&#8195;将训练数据集划分为训练集和验证集，在训练集上训练，周期性在验证集上测试分类精度。当验证集的分类精度达到最值时，停止训练，防止过拟合。<br><img src="/img/MMlab/7.png" alt="早停"><h4 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络(CNN)"></a>卷积神经网络(CNN)</h4>特性：<br>&#8195;&#8195;1.局部连接：像素局部相关<br>&#8195;&#8195;2.共享权重：位移不变性<br><strong>优点</strong>：大量节约参数，有效提取图像特征<br><strong>流程结构</strong>：输入图像 - 卷积层 - 激活层 - 池化层 - 全连接层 - 概率输出 - 类别概率</li></ul><h2 id="4-几个热门AI研究方向"><a href="#4-几个热门AI研究方向" class="headerlink" title="4.几个热门AI研究方向"></a>4.几个热门AI研究方向</h2><ul><li>人工智能的可解释性分析、显著性分析</li><li>图机器学习、图神经网络( AlphaFold2)、知识图谱</li><li>人工智能 + VR/AR/数字人/元宇宙</li><li>轻量化压缩部署 : Web前端、智能手机、服务器、嵌入式硬件</li><li>Al4Science：天文、物理、蛋白质预测、药物设计、数学证明</li><li>做各行各业垂直细分领域的人工智能应用</li><li>神经辐射场 ( NERF )</li><li>扩散生成模型 ( Diffusion )、AIGC、跨模态预训练大模型</li><li>隐私计算、联邦学习、可信计算</li><li>AI基础设施平台( 数据、算力、教学、开源、算法工具包 )</li><li>认知科学 +类脑计算 + 计算神经科学</li></ul>]]></content>
      
      
      <categories>
          
          <category> MMLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MMLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>灰度图像变换——阈值化处理</title>
      <link href="/2023/01/13/%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E9%98%88%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86/"/>
      <url>/2023/01/13/%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E9%98%88%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1、OTSU阈值化"><a href="#1、OTSU阈值化" class="headerlink" title="1、OTSU阈值化"></a>1、OTSU阈值化</h2><p>&#8195;&#8195;最大类间方差算法，步骤如下：<br>&#8195;&#8195;统计每个像素在整幅图中的个数——计算每个像素的概率分布——对灰度值进行遍历搜索，计算当前灰度值下前景背景类间概率——通过目标函数计算出类内与类间方差下对应的阈值。<br>&#8195;&#8195;代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">OTSU</span><span class="params">(Mat srcImg)</span><span class="comment">//输入灰度图像</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> nCols = srcImg.cols;<span class="comment">//纵方向x</span></span><br><span class="line"><span class="type">int</span> nRows = srcImg.rows;<span class="comment">//横方向y</span></span><br><span class="line"><span class="type">int</span> threshold = <span class="number">0</span>;<span class="comment">//输出的灰度阈值</span></span><br><span class="line"><span class="type">int</span> nSumPix[<span class="number">256</span>];<span class="comment">//灰度级统计数组</span></span><br><span class="line"><span class="type">float</span> nProDis[<span class="number">256</span>];<span class="comment">//灰度级概率分布数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)<span class="comment">//初始化统计数组</span></span><br><span class="line">&#123;</span><br><span class="line">nSumPix[i] = <span class="number">0</span>;</span><br><span class="line">nProDis[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nRows; i++)<span class="comment">//统计灰度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nCols; j++)</span><br><span class="line">&#123;</span><br><span class="line">nSumPix[(<span class="type">int</span>)srcImg.<span class="built_in">at</span>&lt;uchar&gt;(i, j)]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)<span class="comment">//计算概率分布</span></span><br><span class="line">&#123;</span><br><span class="line">nProDis[i] = (<span class="type">float</span>)nSumPix[i] / (nCols * nRows);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历灰度级[0, 255]，计算出最大类间方差下的阈值</span></span><br><span class="line"><span class="type">float</span> w0, w1, u0_temp, u1_temp, u0, u1, delta_temp;</span><br><span class="line"><span class="type">double</span> delta_max = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">w0 = w1 = u0_temp = u1_temp = u0 = u1 = delta_temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt;= i)<span class="comment">//背景</span></span><br><span class="line">&#123;</span><br><span class="line">w0 += nProDis[j];</span><br><span class="line">u0_temp += j * nProDis[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//前景</span></span><br><span class="line">&#123;</span><br><span class="line">w1 += nProDis[j];</span><br><span class="line">u1_temp += j * nProDis[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求平均灰度</span></span><br><span class="line">u0 = u0_temp / w0;</span><br><span class="line">u1 = u1_temp / w1;</span><br><span class="line">delta_temp = (<span class="type">float</span>)(w0 * w1 * <span class="built_in">pow</span>((u0 - u1), <span class="number">2</span>));<span class="comment">//求方差</span></span><br><span class="line"><span class="keyword">if</span> (delta_temp &gt; delta_max)<span class="comment">//找出最大方差</span></span><br><span class="line">&#123;</span><br><span class="line">delta_max = delta_temp;</span><br><span class="line">threshold = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> threshold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">Mat srcGray;</span><br><span class="line"><span class="type">int</span> ostuThresHold = <span class="built_in">OTSU</span>(srcGray);<span class="comment">//得到阈值</span></span><br><span class="line">Mat otImg = Mat::<span class="built_in">zeros</span>(srcGray.rows, srcGray.cols, CV_8UC1);<span class="comment">//创建二值图像</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; srcGray.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; srcGray.cols; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (srcGray.<span class="built_in">at</span>&lt;uchar&gt;(i, j) &gt; ostuThresHold)<span class="comment">//灰度像素读取操作</span></span><br><span class="line">otImg.<span class="built_in">at</span>&lt;uchar&gt;(i, j) = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">otImg.<span class="built_in">at</span>&lt;uchar&gt;(i, j) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;otImg_2&quot;</span>, otImg);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2、固定阈值化"><a href="#2、固定阈值化" class="headerlink" title="2、固定阈值化"></a>2、固定阈值化</h2><p>&#8195;&#8195;利用阈值化函数threshold：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">threshold</span> <span class="params">(InputArray src, OutputArray dst, <span class="type">double</span> thresh, <span class="type">double</span> maxval, <span class="type">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure></p><ul><li>src:单通道图像组</li><li>dst:输出图像组（与输入图像同样尺寸和类型）</li><li>thresh:表示二值化的分界阈值[0, 255]</li><li>maxVal:表示二值化的最大值[0, 255]<br>OpenCV提供了THRESH_BINARY和THRESH_BINARY_INV两种默认参数，或者定义为：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxVal = <span class="number">255</span>;</span><br></pre></td></tr></table></figure></li><li>type:表示阈值化处理的类型<br>0、1：非黑[255]即白[0]<br>2、3、4：可利用参数maxVal自设</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">type 代码类型</th><th style="text-align:center">值</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">THRESH_BINARY<br>二进制阈值化</td><td style="text-align:center">0</td><td style="text-align:center">$dst\left( x,y \right) =\begin{cases}    \max  val&amp;        src\left( x,y \right) &gt;thresh\\    0&amp;        \text{其他}\\\end{cases}$</td></tr><tr><td style="text-align:center">THRESH_BINARY_INV<br>反二进制阈值化</td><td style="text-align:center">1</td><td style="text-align:center">$dst\left( x,y \right) =\begin{cases}    \max  val&amp;        src\left( x,y \right) \leqslant thresh\\    0&amp;        \text{其他}\\\end{cases}$</td></tr><tr><td style="text-align:center">THRESH_TRUNC<br>截断阈值化</td><td style="text-align:center">2</td><td style="text-align:center">$dst\left( x,y \right) =\begin{cases}    threshold&amp;        src\left( x,y \right) &gt;thresh\\    src\left( x,y \right)&amp;        \text{其他}\\\end{cases}$</td></tr><tr><td style="text-align:center">THRESH_TOZERO<br>阈值化为0</td><td style="text-align:center">3</td><td style="text-align:center">$dst\left( x,y \right) =\begin{cases}    src\left( x,y \right)&amp;        src\left( x,y \right) &gt;thresh\\    0&amp;        \text{其他}\\\end{cases}$</td></tr><tr><td style="text-align:center">THRESH_TOZERO_INV<br>反阈值化为0</td><td style="text-align:center">4</td><td style="text-align:center">$dst\left( x,y \right) =\begin{cases}    threshold&amp;        src\left( x,y \right) &gt;thresh\\    src\left( x,y \right)&amp;        \text{其他}\\\end{cases}$</td></tr></tbody></table></div><h2 id="3、自适应阈值化"><a href="#3、自适应阈值化" class="headerlink" title="3、自适应阈值化"></a>3、自适应阈值化</h2><p>&#8195;&#8195;利用函数adaptiveThreshold：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">adaptiveThreshold</span> <span class="params">(InputArray src, OutputArray dst, <span class="type">double</span> maxVal, <span class="type">int</span> adaptiveMethod, <span class="type">int</span> thresholdType, <span class="type">int</span> blockSize, <span class="type">double</span> C)</span></span>;</span><br></pre></td></tr></table></figure></p><ul><li>adaptiveMethod:自适应算法<br>0：ADAPTIVE_THRESH_MEAN_C<br>1：ADAPTIVE_THRESH_GAUSSIAN_C</li><li>ThresholdType:阈值类型<br>0：THRESH_BINARY<br>1：THRESH_BINART_INV</li><li>blockSize:表示邻块大小用来计算区域阈值，一般为3、5、7……</li><li>C：常数<br>我也不太清楚怎么设QAQ</li></ul><h2 id="4、双阈值化"><a href="#4、双阈值化" class="headerlink" title="4、双阈值化"></a>4、双阈值化</h2><p>&#8195;&#8195;对于图像中有明显的双分界特征，可以利用双阈值法进行操作。不过需要预先设定好两个阈值量，相当于上界和下界，然后将落在二者中间的像素设定为maxVal，其余的像素设定为0。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">Mat srcImg;</span><br><span class="line"><span class="comment">//初始化参数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxVal = <span class="number">255</span>;</span><br><span class="line"><span class="type">int</span> low_threshold=<span class="number">150</span>;</span><br><span class="line"><span class="type">int</span> high_threshold=<span class="number">210</span>;</span><br><span class="line">Mat temp1, temp2, resImg;</span><br><span class="line"><span class="comment">//小阈值操作</span></span><br><span class="line"><span class="built_in">threshold</span>(srcImg, temp1, low_threshold, maxVal, THRESH_BINARY);</span><br><span class="line"><span class="comment">//大阈值操作</span></span><br><span class="line"><span class="built_in">threshold</span>(srcImg, temp2, high_threshold, maxVal, THRESH_BINARY_INV);</span><br><span class="line"><span class="comment">//矩阵与运算得到二值化结果</span></span><br><span class="line"><span class="built_in">bitwise_and</span>(temp1, temp2, resImg);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计之“分赌注问题”</title>
      <link href="/2023/01/12/%E5%88%86%E8%B5%8C%E6%B3%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2023/01/12/%E5%88%86%E8%B5%8C%E6%B3%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><center>摘要</center></h2><p>&#8195;&#8195;分赌注问题又称为点数问题，是法国学者梅雷于1654年向法国数学家帕斯卡提出的。<br>&#8195;&#8195;该问题简单来说就是两个水平相同的赌徒A和B，约定先胜$t$局的人赢得赌注，在赌局中的某时刻，两赌徒终止赌博，此时A胜$r$局，B胜$s$局，应该如何合理分配赌注。赌注问题不仅成为概率论的起源，同时荷兰数学家惠更斯在此基础上撰写《论赌博中的计算》一书，提出了数学期望的概念，推动了概率论的发展。<br>&#8195;&#8195;本文用理论分析运算得出赌注分配的最佳方案，并采用MATLAB仿真实验验证结果的正确性。</p><h2 id="一、问题假设"><a href="#一、问题假设" class="headerlink" title="一、问题假设"></a>一、问题假设</h2><ul><li>假设先胜18局的人赢得赌注，且在A胜10局且B胜7局的时候终止赌博；</li><li>假设赌徒A和B的胜率相同，即每一局A和B都有0.5的机会赢得胜利；</li><li>由于$r$和$s$的大小不影响问题的讨论，不妨假设$r&gt;s$。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">符号说明</th></tr></thead><tbody><tr><td style="text-align:center">$t$</td><td style="text-align:center">获得赌注需要获胜的次数</td></tr><tr><td style="text-align:center">$r$</td><td style="text-align:center">A已经获胜的次数</td></tr><tr><td style="text-align:center">$s$</td><td style="text-align:center">B已经获胜的次数</td></tr><tr><td style="text-align:center">$P_A$</td><td style="text-align:center">A先获胜$t$局的概率</td></tr><tr><td style="text-align:center">$P_B$</td><td style="text-align:center">B先获胜$s$局的概率</td></tr><tr><td style="text-align:center">$P_a$</td><td style="text-align:center">A获胜一局的概率</td></tr><tr><td style="text-align:center">$P_b$</td><td style="text-align:center">B获胜一局的概率</td></tr><tr><td style="text-align:center">$i$</td><td style="text-align:center">比赛结束时的比赛次数</td></tr><tr><td style="text-align:center">$P_{A\left( i \right)}$</td><td style="text-align:center">进行到第$i$局时A先获胜$t$局的概率</td></tr></tbody></table></div><h2 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h2><p>&#8195;&#8195;当终止赌博时，A胜$r$局，B胜$s$局，那么此时A、B两人中任何一人若要赢得$t$次的胜利，最少需要的局数为$t-r$局，最多需要的局数为$2t-r-s-1$局，即有：</p><center> $t-r\leqslant i\leqslant 2t-r-s-1$ </center>&#8195;&#8195;而通过分析我们可以知道，A要想赢得赌注，他必须要再赢$t-s$局；同样，B要想赢得赌注，他必须要再赢$t-r$局，那么问题便可以转化为A再赢$t-r$局或B再赢$t-s$局先发生的概率，由于结果要么A赢得赌注，要么B赢得赌注，这两个概率是互补的，因此可以得到：<center> $P_A+P_B=1$ </center>&#8195;&#8195;由二项分布可以得出，当进行到了第$i$局时，A先获胜$t$局的概率为：<center> $P_{A\left( i \right)}=C_{i-1}^{t-r-1}P_{a}^{t-r-1}P_{b}^{i-1-\left( t-r-1 \right)}*P_a$ </center>&#8195;&#8195;那么对每一局的概率进行求和便可得出A先获胜$t$局的概率为：<center> $P_A=\sum_{i=t-r}^{2t-r-s-1}{P_{A\left( i \right)} }$</center>&#8195;&#8195;联立上述式子，并结合已知条件，可以得到：<center> $\begin{cases}    t=18\\ r=10\\ s=7\\    P_A+P_B=1\\    P_a=P_b=0.5\\ P_{A\left( i \right)}=C_{i-1}^{t-r-1}P_{a}^{t-r-1}P_{b}^{i-1-\left( t-r-1 \right)}*P_a\\ P_A=\sum_{i=t-r}^{2t-r-s-1}{P_{A\left( i \right)} }\\ \end{cases}$</center><h2 id="三、问题求解"><a href="#三、问题求解" class="headerlink" title="三、问题求解"></a>三、问题求解</h2><ol><li>编写MATLAB程序，对上述方程组进行求解：<br>&#8195;&#8195;通过计算得出理论值为：$P_A=0.7597$。<br>&#8195;&#8195;因此A应该赢得75.97%的赌注，B应该赢得24.03%的赌注。</li><li>利用MATLAB仿真实验对理论结果进行验证：<br>&#8195;&#8195;假设MATLAB中2*rand()产生的随机数大于1则认为单局赌博A获胜，否则B获胜。以A获胜次数/仿真次数为A获胜的频率，得到仿真结果如下表：</li></ol><center><font face="黑体">表 1 仿真结果统计表</font></center><div class="table-container"><table><thead><tr><th style="text-align:center">仿真次数</th><th style="text-align:center">10</th><th style="text-align:center">100</th><th style="text-align:center">1000</th><th style="text-align:center">10000</th></tr></thead><tbody><tr><td style="text-align:center">A获胜的频率</td><td style="text-align:center">0.8000</td><td style="text-align:center">0.7700</td><td style="text-align:center">0.7530</td><td style="text-align:center">0.7596</td></tr></tbody></table></div><p>&#8195;&#8195;可以看出，当仿真次数为10000次时，A获胜的频率为0.7596，与理论计算的结果相符合，印证了本文采取的计算方法的正确性。</p><h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><blockquote><font color=black>[1]张卓奎，陈慧婵.《概率论与数理统计》. 西安电子科技大学出版社. 2014.6</font></blockquote><h2 id="五、附录"><a href="#五、附录" class="headerlink" title="五、附录"></a>五、附录</h2><figure class="highlight m"><figcaption><span>求解代码</span></figcaption><table><tr><td class="code"><pre><span class="line">clc;clear</span><br><span class="line">t <span class="built_in">=</span> <span class="number">18</span>;</span><br><span class="line">r <span class="built_in">=</span> <span class="number">10</span>;</span><br><span class="line">s <span class="built_in">=</span> <span class="number">7</span>;</span><br><span class="line">p_a <span class="built_in">=</span> <span class="number">0.5</span>;</span><br><span class="line">P_A <span class="built_in">=</span> P(t - r,t - s, p_a)</span><br><span class="line"><span class="comment">%定义 n = t - r; m = t - s</span></span><br><span class="line">function sum <span class="built_in">=</span> P(n, m, p)</span><br><span class="line">    sum <span class="built_in">=</span> <span class="number">0</span>;</span><br><span class="line">    for i <span class="built_in">=</span> n : n + m - <span class="number">1</span></span><br><span class="line">        sum <span class="built_in">=</span> sum + nchoosek(n + m - <span class="number">1</span>, i) * p^(i) * (<span class="number">1</span> - p)^(n + m - <span class="number">1</span> - i);</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><figure class="highlight m"><figcaption><span>仿真代码</span></figcaption><table><tr><td class="code"><pre><span class="line">clear;clc</span><br><span class="line">t <span class="built_in">=</span> <span class="number">18</span>;</span><br><span class="line">r <span class="built_in">=</span> <span class="number">10</span>;</span><br><span class="line">s <span class="built_in">=</span> <span class="number">7</span>;</span><br><span class="line">cout <span class="built_in">=</span> <span class="number">10000</span>;</span><br><span class="line">cout_a <span class="built_in">=</span> <span class="number">0</span>;</span><br><span class="line">cout_b <span class="built_in">=</span> <span class="number">0</span>;</span><br><span class="line">for i <span class="built_in">=</span> <span class="number">1</span> : cout</span><br><span class="line">    i_a <span class="built_in">=</span> r;</span><br><span class="line">    i_b <span class="built_in">=</span> s;</span><br><span class="line">    while i_a &lt; t &amp;&amp; i_b &lt; t</span><br><span class="line">        <span class="built_in">if</span>(<span class="number">2</span> * rand() &gt; <span class="number">1</span>)</span><br><span class="line">            i_a <span class="built_in">=</span> i_a + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">else</span></span><br><span class="line">            i_b <span class="built_in">=</span> i_b + <span class="number">1</span>;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">if</span> i_a <span class="built_in">=</span><span class="built_in">=</span> t</span><br><span class="line">        cout_a <span class="built_in">=</span> cout_a + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">else</span></span><br><span class="line">        cout_b <span class="built_in">=</span> cout_b + <span class="number">1</span>;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">P_A <span class="built_in">=</span> cout_a / cout</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/11/hello-world/"/>
      <url>/2023/01/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
