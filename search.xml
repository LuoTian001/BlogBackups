<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>灰度图像变换——阈值化处理“</title>
      <link href="/2023/01/13/%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E9%98%88%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86/"/>
      <url>/2023/01/13/%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E9%98%88%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="灰度图像变换——阈值化处理"><a href="#灰度图像变换——阈值化处理" class="headerlink" title="灰度图像变换——阈值化处理"></a><center>灰度图像变换——阈值化处理</center></h2><h2 id="1、OTSU阈值化"><a href="#1、OTSU阈值化" class="headerlink" title="1、OTSU阈值化"></a>1、OTSU阈值化</h2><p>&#8195;&#8195;最大类间方差算法，步骤如下：<br>&#8195;&#8195;统计每个像素在整幅图中的个数——计算每个像素的概率分布——对灰度值进行遍历搜索，计算当前灰度值下前景背景类间概率——通过目标函数计算出类内与类间方差下对应的阈值。<br>&#8195;&#8195;代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">OTSU</span><span class="params">(Mat srcImg)</span><span class="comment">//输入灰度图像</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> nCols = srcImg.cols;<span class="comment">//纵方向x</span></span><br><span class="line"><span class="type">int</span> nRows = srcImg.rows;<span class="comment">//横方向y</span></span><br><span class="line"><span class="type">int</span> threshold = <span class="number">0</span>;<span class="comment">//输出的灰度阈值</span></span><br><span class="line"><span class="type">int</span> nSumPix[<span class="number">256</span>];<span class="comment">//灰度级统计数组</span></span><br><span class="line"><span class="type">float</span> nProDis[<span class="number">256</span>];<span class="comment">//灰度级概率分布数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)<span class="comment">//初始化统计数组</span></span><br><span class="line">&#123;</span><br><span class="line">nSumPix[i] = <span class="number">0</span>;</span><br><span class="line">nProDis[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nRows; i++)<span class="comment">//统计灰度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nCols; j++)</span><br><span class="line">&#123;</span><br><span class="line">nSumPix[(<span class="type">int</span>)srcImg.<span class="built_in">at</span>&lt;uchar&gt;(i, j)]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)<span class="comment">//计算概率分布</span></span><br><span class="line">&#123;</span><br><span class="line">nProDis[i] = (<span class="type">float</span>)nSumPix[i] / (nCols * nRows);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历灰度级[0, 255]，计算出最大类间方差下的阈值</span></span><br><span class="line"><span class="type">float</span> w0, w1, u0_temp, u1_temp, u0, u1, delta_temp;</span><br><span class="line"><span class="type">double</span> delta_max = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">w0 = w1 = u0_temp = u1_temp = u0 = u1 = delta_temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt;= i)<span class="comment">//背景</span></span><br><span class="line">&#123;</span><br><span class="line">w0 += nProDis[j];</span><br><span class="line">u0_temp += j * nProDis[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//前景</span></span><br><span class="line">&#123;</span><br><span class="line">w1 += nProDis[j];</span><br><span class="line">u1_temp += j * nProDis[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求平均灰度</span></span><br><span class="line">u0 = u0_temp / w0;</span><br><span class="line">u1 = u1_temp / w1;</span><br><span class="line">delta_temp = (<span class="type">float</span>)(w0 * w1 * <span class="built_in">pow</span>((u0 - u1), <span class="number">2</span>));<span class="comment">//求方差</span></span><br><span class="line"><span class="keyword">if</span> (delta_temp &gt; delta_max)<span class="comment">//找出最大方差</span></span><br><span class="line">&#123;</span><br><span class="line">delta_max = delta_temp;</span><br><span class="line">threshold = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> threshold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">Mat srcGray;</span><br><span class="line"><span class="type">int</span> ostuThresHold = <span class="built_in">OTSU</span>(srcGray);<span class="comment">//得到阈值</span></span><br><span class="line">Mat otImg = Mat::<span class="built_in">zeros</span>(srcGray.rows, srcGray.cols, CV_8UC1);<span class="comment">//创建二值图像</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; srcGray.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; srcGray.cols; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (srcGray.<span class="built_in">at</span>&lt;uchar&gt;(i, j) &gt; ostuThresHold)<span class="comment">//灰度像素读取操作</span></span><br><span class="line">otImg.<span class="built_in">at</span>&lt;uchar&gt;(i, j) = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">otImg.<span class="built_in">at</span>&lt;uchar&gt;(i, j) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;otImg_2&quot;</span>, otImg);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2、固定阈值化"><a href="#2、固定阈值化" class="headerlink" title="2、固定阈值化"></a>2、固定阈值化</h2><p>&#8195;&#8195;利用阈值化函数threshold：</p><blockquote><p>double threshold (InputArray src, OutputArray dst, double thresh, double maxval, int type)</p><ul><li>src:单通道图像组</li><li>dst:输出图像组（与输入图像同样尺寸和类型）</li><li>thresh:表示二值化的分界阈值[0, 255]</li><li>maxVal:表示二值化的最大值[0, 255]<br>OpenCV提供了THRESH_BINARY和THRESH_BINARY_INV两种默认参数，或者定义为：<br>const int maxVal = 255</li><li>type:表示阈值化处理的类型<br>0、1：非黑[255]即白[0]<br>2、3、4：可利用参数maxVal自设</li></ul></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">type 代码类型</th><th style="text-align:center">值</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">THRESH_BINARY<br>二进制阈值化</td><td style="text-align:center">0</td><td style="text-align:center">$dst\left( x,y \right) =\begin{cases}    \max  val&amp;        src\left( x,y \right) &gt;thresh\\    0&amp;        \text{其他}\\\end{cases}$</td></tr><tr><td style="text-align:center">THRESH_BINARY_INV<br>反二进制阈值化</td><td style="text-align:center">1</td><td style="text-align:center">$dst\left( x,y \right) =\begin{cases}    \max  val&amp;        src\left( x,y \right) \leqslant thresh\\    0&amp;        \text{其他}\\\end{cases}$</td></tr><tr><td style="text-align:center">THRESH_TRUNC<br>截断阈值化</td><td style="text-align:center">2</td><td style="text-align:center">$dst\left( x,y \right) =\begin{cases}    threshold&amp;        src\left( x,y \right) &gt;thresh\\    src\left( x,y \right)&amp;        \text{其他}\\\end{cases}$</td></tr><tr><td style="text-align:center">THRESH_TOZERO<br>阈值化为0</td><td style="text-align:center">3</td><td style="text-align:center">$dst\left( x,y \right) =\begin{cases}    src\left( x,y \right)&amp;        src\left( x,y \right) &gt;thresh\\    0&amp;        \text{其他}\\\end{cases}$</td></tr><tr><td style="text-align:center">THRESH_TOZERO_INV<br>反阈值化为0</td><td style="text-align:center">4</td><td style="text-align:center">$dst\left( x,y \right) =\begin{cases}    threshold&amp;        src\left( x,y \right) &gt;thresh\\    src\left( x,y \right)&amp;        \text{其他}\\\end{cases}$</td></tr></tbody></table></div><h2 id="3、自适应阈值化"><a href="#3、自适应阈值化" class="headerlink" title="3、自适应阈值化"></a>3、自适应阈值化</h2><p>&#8195;&#8195;利用函数adaptiveThreshold：</p><blockquote><p>void adaptiveThreshold (InputArray src, OutputArray dst, double maxVal, int adaptiveMethod, int thresholdType, int blockSize, double C)</p><ul><li>adaptiveMethod:自适应算法<br>0：ADAPTIVE_THRESH_MEAN_C<br>1：ADAPTIVE_THRESH_GAUSSIAN_C</li><li>ThresholdType:阈值类型<br>0：THRESH_BINARY<br>1：THRESH_BINART_INV</li><li>blockSize:表示邻块大小用来计算区域阈值，一般为3、5、7……</li><li>C：常数<br>我也不太清楚怎么设</li></ul></blockquote><h2 id="4、双阈值化"><a href="#4、双阈值化" class="headerlink" title="4、双阈值化"></a>4、双阈值化</h2><p>&#8195;&#8195;对于图像中有明显的双分界特征，可以利用双阈值法进行操作。不过需要预先设定好两个阈值量，相当于上界和下界，然后将落在二者中间的像素设定为maxVal，其余的像素设定为0。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">Mat srcImg;</span><br><span class="line"><span class="comment">//初始化参数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxVal = <span class="number">255</span>;</span><br><span class="line"><span class="type">int</span> low_threshold=<span class="number">150</span>;</span><br><span class="line"><span class="type">int</span> high_threshold=<span class="number">210</span>;</span><br><span class="line">Mat temp1, temp2, resImg;</span><br><span class="line"><span class="comment">//小阈值操作</span></span><br><span class="line"><span class="built_in">threshold</span>(srcImg, temp1, low_threshold, maxVal, THRESH_BINARY);</span><br><span class="line"><span class="comment">//大阈值操作</span></span><br><span class="line"><span class="built_in">threshold</span>(srcImg, temp2, high_threshold, maxVal, THRESH_BINARY_INV);</span><br><span class="line"><span class="comment">//矩阵与运算得到二值化结果</span></span><br><span class="line"><span class="built_in">bitwise_and</span>(temp1, temp2, resImg);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计之“分赌注问题”</title>
      <link href="/2023/01/12/%E5%88%86%E8%B5%8C%E6%B3%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2023/01/12/%E5%88%86%E8%B5%8C%E6%B3%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><center>摘要</center></h2><p>&#8195;&#8195;分赌注问题又称为点数问题，是法国学者梅雷于1654年向法国数学家帕斯卡提出的。<br>&#8195;&#8195;该问题简单来说就是两个水平相同的赌徒A和B，约定先胜$t$局的人赢得赌注，在赌局中的某时刻，两赌徒终止赌博，此时A胜$r$局，B胜$s$局，应该如何合理分配赌注。赌注问题不仅成为概率论的起源，同时荷兰数学家惠更斯在此基础上撰写《论赌博中的计算》一书，提出了数学期望的概念，推动了概率论的发展。<br>&#8195;&#8195;本文用理论分析运算得出赌注分配的最佳方案，并采用MATLAB仿真实验验证结果的正确性。</p><h2 id="一、问题假设"><a href="#一、问题假设" class="headerlink" title="一、问题假设"></a>一、问题假设</h2><ul><li>假设先胜18局的人赢得赌注，且在A胜10局且B胜7局的时候终止赌博；</li><li>假设赌徒A和B的胜率相同，即每一局A和B都有0.5的机会赢得胜利；</li><li>由于$r$和$s$的大小不影响问题的讨论，不妨假设$r&gt;s$。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">符号说明</th></tr></thead><tbody><tr><td style="text-align:center">$t$</td><td style="text-align:center">获得赌注需要获胜的次数</td></tr><tr><td style="text-align:center">$r$</td><td style="text-align:center">A已经获胜的次数</td></tr><tr><td style="text-align:center">$s$</td><td style="text-align:center">B已经获胜的次数</td></tr><tr><td style="text-align:center">$P_A$</td><td style="text-align:center">A先获胜$t$局的概率</td></tr><tr><td style="text-align:center">$P_B$</td><td style="text-align:center">B先获胜$s$局的概率</td></tr><tr><td style="text-align:center">$P_a$</td><td style="text-align:center">A获胜一局的概率</td></tr><tr><td style="text-align:center">$P_b$</td><td style="text-align:center">B获胜一局的概率</td></tr><tr><td style="text-align:center">$i$</td><td style="text-align:center">比赛结束时的比赛次数</td></tr><tr><td style="text-align:center">$P_{A\left( i \right)}$</td><td style="text-align:center">进行到第$i$局时A先获胜$t$局的概率</td></tr></tbody></table></div><h2 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h2><p>&#8195;&#8195;当终止赌博时，A胜$r$局，B胜$s$局，那么此时A、B两人中任何一人若要赢得$t$次的胜利，最少需要的局数为$t-r$局，最多需要的局数为$2t-r-s-1$局，即有：</p><center> $t-r\leqslant i\leqslant 2t-r-s-1$ </center>&#8195;&#8195;而通过分析我们可以知道，A要想赢得赌注，他必须要再赢$t-s$局；同样，B要想赢得赌注，他必须要再赢$t-r$局，那么问题便可以转化为A再赢$t-r$局或B再赢$t-s$局先发生的概率，由于结果要么A赢得赌注，要么B赢得赌注，这两个概率是互补的，因此可以得到：<center> $P_A+P_B=1$ </center>&#8195;&#8195;由二项分布可以得出，当进行到了第$i$局时，A先获胜$t$局的概率为：<center> $P_{A\left( i \right)}=C_{i-1}^{t-r-1}P_{a}^{t-r-1}P_{b}^{i-1-\left( t-r-1 \right)}*P_a$ </center>&#8195;&#8195;那么对每一局的概率进行求和便可得出A先获胜$t$局的概率为：<center> $P_A=\sum_{i=t-r}^{2t-r-s-1}{P_{A\left( i \right)} }$</center>&#8195;&#8195;联立上述式子，并结合已知条件，可以得到：<center> $\begin{cases}    t=18\\ r=10\\ s=7\\    P_A+P_B=1\\    P_a=P_b=0.5\\ P_{A\left( i \right)}=C_{i-1}^{t-r-1}P_{a}^{t-r-1}P_{b}^{i-1-\left( t-r-1 \right)}*P_a\\ P_A=\sum_{i=t-r}^{2t-r-s-1}{P_{A\left( i \right)} }\\ \end{cases}$</center><h2 id="三、问题求解"><a href="#三、问题求解" class="headerlink" title="三、问题求解"></a>三、问题求解</h2><ol><li>编写MATLAB程序，对上述方程组进行求解：<br>&#8195;&#8195;通过计算得出理论值为：$P_A=0.7597$。<br>&#8195;&#8195;因此A应该赢得75.97%的赌注，B应该赢得24.03%的赌注。</li><li>利用MATLAB仿真实验对理论结果进行验证：<br>&#8195;&#8195;假设MATLAB中2*rand()产生的随机数大于1则认为单局赌博A获胜，否则B获胜。以A获胜次数/仿真次数为A获胜的频率，得到仿真结果如下表：</li></ol><center><font face="黑体">表 1 仿真结果统计表</font></center><div class="table-container"><table><thead><tr><th style="text-align:center">仿真次数</th><th style="text-align:center">10</th><th style="text-align:center">100</th><th style="text-align:center">1000</th><th style="text-align:center">10000</th></tr></thead><tbody><tr><td style="text-align:center">A获胜的频率</td><td style="text-align:center">0.8000</td><td style="text-align:center">0.7700</td><td style="text-align:center">0.7530</td><td style="text-align:center">0.7596</td></tr></tbody></table></div><p>&#8195;&#8195;可以看出，当仿真次数为10000次时，A获胜的频率为0.7596，与理论计算的结果相符合，印证了本文采取的计算方法的正确性。</p><h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><blockquote><font color=black>[1]张卓奎，陈慧婵.《概率论与数理统计》. 西安电子科技大学出版社. 2014.6</font></blockquote><h2 id="五、附录"><a href="#五、附录" class="headerlink" title="五、附录"></a>五、附录</h2><figure class="highlight m"><figcaption><span>求解代码</span></figcaption><table><tr><td class="code"><pre><span class="line">clc;clear</span><br><span class="line">t <span class="built_in">=</span> <span class="number">18</span>;</span><br><span class="line">r <span class="built_in">=</span> <span class="number">10</span>;</span><br><span class="line">s <span class="built_in">=</span> <span class="number">7</span>;</span><br><span class="line">p_a <span class="built_in">=</span> <span class="number">0.5</span>;</span><br><span class="line">P_A <span class="built_in">=</span> P(t - r,t - s, p_a)</span><br><span class="line"><span class="comment">%定义 n = t - r; m = t - s</span></span><br><span class="line">function sum <span class="built_in">=</span> P(n, m, p)</span><br><span class="line">    sum <span class="built_in">=</span> <span class="number">0</span>;</span><br><span class="line">    for i <span class="built_in">=</span> n : n + m - <span class="number">1</span></span><br><span class="line">        sum <span class="built_in">=</span> sum + nchoosek(n + m - <span class="number">1</span>, i) * p^(i) * (<span class="number">1</span> - p)^(n + m - <span class="number">1</span> - i);</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><figure class="highlight m"><figcaption><span>仿真代码</span></figcaption><table><tr><td class="code"><pre><span class="line">clear;clc</span><br><span class="line">t <span class="built_in">=</span> <span class="number">18</span>;</span><br><span class="line">r <span class="built_in">=</span> <span class="number">10</span>;</span><br><span class="line">s <span class="built_in">=</span> <span class="number">7</span>;</span><br><span class="line">cout <span class="built_in">=</span> <span class="number">10000</span>;</span><br><span class="line">cout_a <span class="built_in">=</span> <span class="number">0</span>;</span><br><span class="line">cout_b <span class="built_in">=</span> <span class="number">0</span>;</span><br><span class="line">for i <span class="built_in">=</span> <span class="number">1</span> : cout</span><br><span class="line">    i_a <span class="built_in">=</span> r;</span><br><span class="line">    i_b <span class="built_in">=</span> s;</span><br><span class="line">    while i_a &lt; t &amp;&amp; i_b &lt; t</span><br><span class="line">        <span class="built_in">if</span>(<span class="number">2</span> * rand() &gt; <span class="number">1</span>)</span><br><span class="line">            i_a <span class="built_in">=</span> i_a + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">else</span></span><br><span class="line">            i_b <span class="built_in">=</span> i_b + <span class="number">1</span>;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">if</span> i_a <span class="built_in">=</span><span class="built_in">=</span> t</span><br><span class="line">        cout_a <span class="built_in">=</span> cout_a + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">else</span></span><br><span class="line">        cout_b <span class="built_in">=</span> cout_b + <span class="number">1</span>;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">P_A <span class="built_in">=</span> cout_a / cout</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/11/hello-world/"/>
      <url>/2023/01/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
